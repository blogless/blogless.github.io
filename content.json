{"meta":{"title":"博客寥寥","subtitle":"从记笔记转向写博客，就像从写私有项目转向写开源项目一样困难","description":null,"author":"赵恒昶","url":"http://blogless.github.io","root":"/"},"pages":[{"title":"关于作者","date":"2019-08-25T03:09:15.728Z","updated":"2019-08-25T03:09:15.728Z","comments":true,"path":"about/index.html","permalink":"http://blogless.github.io/about/index.html","excerpt":"","text":"搬砖工，写 bug；专注于 Modern C++，喜欢 Node.js；偶尔才会提起兴趣写博客；宅男一枚。"},{"title":"categories","date":"2017-10-04T11:52:36.000Z","updated":"2019-08-25T03:09:15.728Z","comments":true,"path":"categories/index.html","permalink":"http://blogless.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-10-04T11:50:45.000Z","updated":"2019-08-25T03:09:15.732Z","comments":true,"path":"tags/index.html","permalink":"http://blogless.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MPI入门","slug":"MPI入门","date":"2019-08-25T12:44:10.000Z","updated":"2019-09-05T13:20:52.477Z","comments":true,"path":"2019/08/25/MPI入门/","link":"","permalink":"http://blogless.github.io/2019/08/25/MPI入门/","excerpt":"","text":"MPI安装入门参考 https://gist.github.com/pajayrao/166bbeaf029012701f790b6943b31bb2 OS: Ubuntu 18.04 LTS 安装MPI1sudo apt install -y mpich 使用MPI基本函数基本函数列表： 1234MPI_InitMPI_FinalizeMPI_Comm_rankMPI_Comm_size 其中，MPI_Init用于初始化MPI程序，MPI_Finalize用于结束MPI程序，二者应该成对使用（且只用一次），分别放在程序的开始和结束。MPI_Comm_rank和MPI_Comm_rank分别用于获取进程总数和当前进程的序号，一般以 rank 为 0 的进程作为主进程。基本使用方法如下： 1234567891011121314151617#include &lt;mpi.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv) &#123; int rank, size; MPI_Init(&amp;argc, &amp;argv); MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank); MPI_Comm_size(MPI_COMM_WORLD, &amp;size); if (rank == 0) &#123; // do something... &#125; else &#123; // do something else... &#125; MPI_Finalize();&#125; 点对点通信函数点对点的通信原语是 send 和 recv: 12MPI_SendMPI_Recv 群组通信函数广播函数： 1MPI_Bcast 群发群收函数： 123MPI_ScatterMPI_GatherMPI_Allgather Reduce函数： 12MPI_ReduceMPI_Alreduce 以上几组函数的区别是：Bcast会将一份数据完整复制给所有进程，而Scatter把这份数据拆开分给每个进程一部分；Gather从所有进程中收集数据，汇总到一个进程中，而Reduce拿到的是所有进程中数据操作后的结果；Gather和Reduce汇总数据到一个进程，AllXxx是把汇总后的结果分发给每一个进程。","categories":[{"name":"编程","slug":"programming","permalink":"http://blogless.github.io/categories/programming/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://blogless.github.io/tags/C-C/"},{"name":"编程","slug":"编程","permalink":"http://blogless.github.io/tags/编程/"},{"name":"并行","slug":"并行","permalink":"http://blogless.github.io/tags/并行/"}]},{"title":"我差一点就转投hugo了","slug":"我差一点就转投hugo了","date":"2019-08-15T12:57:04.000Z","updated":"2019-09-06T01:58:01.252Z","comments":true,"path":"2019/08/15/我差一点就转投hugo了/","link":"","permalink":"http://blogless.github.io/2019/08/15/我差一点就转投hugo了/","excerpt":"","text":"博客系统迁移：从hexo到hugo电脑重装系统，想起来自己的博客，重装node和hexo之后发现原来的博客无法生成了，看起来是某些依赖版本对不上了，真是令人头大，重新搜索了一下 Static Site Generator，发现了 hugo 这个好东西，决定尝试一下。相比hexo，hugo提供二进制安装，没有依赖，而且速度非常快，令人心旷神怡。如果说有什么缺点的话，那就是hugo主题明显没有hexo精良。 安装hugohugo是用go语言开发的，由大名鼎鼎的spf13发起，安装也很简单，可以源码安装，可以apt安装，也可以snap安装。这里我使用snap安装最新版hugo： 1$ snap install hugo --channel=extended 验证安装： 1$ hugo version 使用snap安装而不是apt的原因是，snap安装的版本比apt新，可以分别通过snap info hugo和apt show hugo查看二者提供的版本信息。 创建博客仓库创建生成博客仓库： 1$ hugo new site blog 使用 git 管理项目： 1$ git init 在 github 上创建一个同名空仓库，之后把本地仓库和远程仓库联系起来： 1234# 首先是本地仓库联系远程仓库$ git remote add origin git@github.com:&lt;your-name&gt;/blog.git# 其次是本地分支联系远程分支，记不住没关系，直接`git pull`会提醒你如何设置的$ git branch --set-upstream-to=origin/master master 最后，把本地仓库同步到远程仓库： 1234# 然后更新本地的origin$ git fetch# 本地同步远程，要求远程仓库为空是为了避免冲突$ git rebase -i origin/master 如果有多个git用户，从而不想设置全局git用户，而是每个仓库单独设置的话，你可能需要在git init之后先输入： 12$ git config user.name \"&lt;your-name&gt;\"$ git config user.email \"&lt;your-email&gt;\" 其实就是省略了 --global 参数 安装主题之前的Hexo博客使用的是indigo主题，这里我想保持迁移前后博客风格一致，以后有需要再修改博客主题，所幸我在hugo themes 找到了最为接近的polymer，安装： 1$ git clone https://github.com/pdevty/polymer.git themes/polymer 或者： 1$ git submodule add https://github.com/pdevty/polymer.git themes/polymer 阅读polymer源码可以发现，左侧栏需要的图标来自 PolymerElements，后面添加的about和archives都需要从这里选取图标。 加入 mathjax 公式支持为保证所有文件都加入Latex公式支持，最好的办法是用一个模板把这个js库引入footer，比如写入到 layouts/partials/footer.html，具体来讲就是把 当前theme下的footer.html 复制到根目录下的layout里，然后添加： 123&lt;script type=\"text/javascript\" src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"&gt;&lt;/script&gt; 参考 https://www.gohugo.org/doc/tutorials/mathjax/Mathjax参数?config=TeX-AMS-MML_HTMLorMML是告诉MathJax，我们要用到的叫TeX-AMS-MML_HTMLorMML.js的配置文件，其用来控制显示数学公式的HTMl显示输出 提速，一是切换到国内的cdn，这里使用的是 BootCDN,Bootstrap中文网提供的CDN服务，选择它的原因是新浪快但是没有资源，百度阿里网站找不到，头条资源很丰富但官网卡死…… 二是按需加载，只有在文章开头加上math: true时才加载mathjax： 1234&#123;&#123;if .Params.math &#125;&#125; &lt;!-- &lt;script src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"&gt;&lt;/script&gt; --&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;&#123;&#123;end&#125;&#125; 解决 markdown 与 mathjax 冲突问题具体来讲就是 latex的换行语法 \\\\ 在markdown会被理解为转义，下标_会被markdown当作强调。修改公式让mathjax适应markdown是不可能的，必须让markdown向mathjax低头，也就是想办法不让markdown解析公式。以后宗办法是使用markdown的代码块（反引号），但是这样有个问题就是代码块有自己的样式，会比较混乱。更好的解决办法是引入html标签，把公式用 &lt;div&gt;&lt;/div&gt; 或者 &lt;p&gt;&lt;/p&gt; 包起来，这样markdown就不会去解析这里面的内容了。 favicon浏览器检测发现有一个资源404，原因是拿不到favicon.ico，也就是浏览器标签栏上 title 左侧的那个小图片，这里我们要做的是自己制作一个favicon。首先我找到了一个制作favicon的网站https://tool.lu/favicon/，然后把博客头像上传，制作后下载到本地static根目录下（注意不能是static/img下），再次刷新网页，favicon已经有了。 ## 创建一个 about 页面： 1$ hugo new about.md 创建第一篇文章，放到 post 目录，方便之后生成聚合页面。 1$ hugo new post/first.md 永久连接 用 title 比用 filename 好 迁移 hexo中markdown博文中metadata中的categories可以不用加[]，但是hugo严格要求加上，与tags保持一致。 左侧几项都应该是single.html (?) 原来hexo里面的categories应该删掉，不然会阻止正常目录功能（或者应该正确组织来定制自己的目录格式？？）同时，tags也可以删掉，about可以拿出来而不用放入单独的文件夹。 12345&lt;!-- 待Archive功能完成后加入到 layouts/partials/header.html --&gt; &lt;a href=&#123;&#123;$baseurl&#125;&#125;/archives/&gt;&lt;paper-item&gt; &lt;iron-icon icon=\"archive\"&gt;&lt;/iron-icon&gt; &lt;div class=\"flex\"&gt;Archives&lt;/div&gt; &lt;iron-icon icon=\"chevron-right\"&gt;&lt;/iron-icon&gt; &lt;/paper-item&gt;&lt;/a&gt; 把博文文件夹从 _posts 改名为 post 以使用永久连接匹配的post _drafts 文件夹不能表示文件是草稿了，要在每个草稿文件头部 加入 draft:true 才行了。 图片不能放在博文目录下了，要放到static/img下去 TODO 添加 archive、about 添加 copyright &amp; license 添加 subtitle 添加 description 添加 highlight 添加 评论系统 添加 TOC (table of content) 添加 回到顶部 上一篇/下一篇 图标处 添加文章名称 about 单页去除 上一篇/下一篇 123hurray 最先fork，有个bugfix，6提交stephen-marshall-moore 44提交，质量很高tonychee7000 111提交，都是灌水 更好的主题选择功能全，持续更新，编译后网页速度快 飞雪无情的theme，比较不符合我的审美，但是功能齐全，持续更新 但是这个功能也不全： Toc 需要在每篇文章手动开启 只有see also， 没有上一篇/下一篇 据说 see also 只显示发表时间早于当前文章的？ 没有站内搜索（只能借助于google站内搜索之内的办法） 这个主题可以使用基于github issue的 utterances 使用起来非常简单，参考博客使用 utterances 作为评论系统 打退堂鼓了尝试完之后，我又暂时退回了hexo阵营，为什么呢？最关键的原因在于，就连maupassant-hugo这个目前最佳的主题都没有提供站内搜索啊！！！相比之下hexo的基于jsonContent这种站内搜索才是我的最爱。所以，我又缩回去了，重新安装了hexo+indigo最新版，并不费时间。","categories":[{"name":"随笔","slug":"other","permalink":"http://blogless.github.io/categories/other/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://blogless.github.io/tags/博客/"},{"name":"随笔","slug":"随笔","permalink":"http://blogless.github.io/tags/随笔/"}]},{"title":"Modern C++","slug":"Modern-C","date":"2017-10-27T10:30:01.000Z","updated":"2019-09-05T12:22:23.899Z","comments":true,"path":"2017/10/27/Modern-C/","link":"","permalink":"http://blogless.github.io/2017/10/27/Modern-C/","excerpt":"","text":"引言在语言的进化上，C++ 走了一条不同的路。当其他编程语言 TODO: 时，C++ 却在 TODO: 的道路上 动机与 C++0x 相比，C++11 进行了大幅度的改进，几乎将古老的 C++ 改造成了另一门现代编程语言，这也让 C++ 重新焕发生机。C++14、C++17 都可以看作是对 C++11 的补充和完善，下面我将对 Modern C++ 部分特性进行概述。 正文类型推导作为一门强类型的语言，C++ 有着严格的静态类型检查约束。一方面，这大大减少了动态类型语言可能遇到的各种错误的发生；另一方面，复杂类型的使用也变得麻烦起来。幸运的是，现代 C++ 解决了这个问题，曾经让作者痛恨的复杂类型的声明一去不复返了（比如，容器迭代器的声明……）。 需要指出的是，使用类型推导并不会降低程序的性能。因为在进行静态类型检查的时候，本来就是要进行类型推导，然后查看声明的类型与之是否匹配的。所以，在不影响程序可读性的情况下，尽可以放心大胆地使用类型推导（尤其是auto）。 你需要学会使用的关键字有两个：auto 和 decltype，他们是一对逆操作的关系。 auto：根据右值推导出其类型，即参数类型依赖于返回值类型，（所以 auto 变量声明的时候必须初始化） decltype：根据表达式推导出其类型，即返回值类型倚赖于参数类型 智能指针现代 C++ 将指针封装起来，不提倡直接使用 裸指针 操作内存，而是提供了特性更好的智能指针来管理内存，减少使用 delete。提倡 RAII （“获取资源即初始化”），提供的指针包括： auto_ptr：已过时； unique_ptr：独占所有权的指针（不能拷贝，只许 move），支持右值引用、所有权转移，能够轻松转换为 shared_ptr，auto_ptr 的替代者，通常利用 工厂函数 生成； shared_ptr：采用引用计数管理资源的生命周期的智能指针； weak_ptr：替换会造成悬挂的 shared_ptr ，不参与引用计数； 优先使用 std::make_unique 和 std::make_shared 来生成指针，而不是使用 share_ptr&lt;ClassA&gt;(new ClassA())，减少使用 new。智能指针是在 &lt;memory&gt; 标头文件中的 std 命名空间中定义的。 初始化C++11 支持多种初始化方式，你可用的包括： 等号 =; 小括号 (); 大括号 {}； 但是他们之间是不同的，= 是赋值，(){}是构造函数；STL 容器在调用 () 和 {} 完成初始化的时候的行为是不一样的，() 传入构造参数，而 {} 则传入初始化元素； 类中的成员变量提倡赋默认值，基本数据类型也提倡使用 {} 来初始化，优势是值类型不会自动 narrow，比如 unsigned char i = {-1};会报错。 参考http://www.cnblogs.com/boydfd/category/753605.html 友善度鉴于作者水平有限，错误疏漏在所难免，欢迎进入这里批评指正 完附：左值与右值左值能被取地址，右值不能被取地址；左值既能在等号左边，又能在等号右边，右值只能在等号右边；左值是非临时对象，右值是临时对象；","categories":[{"name":"编程","slug":"programming","permalink":"http://blogless.github.io/categories/programming/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://blogless.github.io/tags/C-C/"},{"name":"编程","slug":"编程","permalink":"http://blogless.github.io/tags/编程/"}]},{"title":"你应该避免的C++糟粕","slug":"你应该避免的C-糟粕","date":"2017-10-26T10:29:51.000Z","updated":"2019-09-06T01:38:07.557Z","comments":true,"path":"2017/10/26/你应该避免的C-糟粕/","link":"","permalink":"http://blogless.github.io/2017/10/26/你应该避免的C-糟粕/","excerpt":"","text":"引子很多公司招人的时候，都会招聘 C/C++程序员，然而世界上并不存在 C/C++ 这门语言。即使在早期设计的时候，C++ 是完全兼容 C 的，但是经过这么多年的发展，C++ 已经发展成了和 C 有着明显区别的一种语言，甚至于兼容 C 的部分早就成为了 C++ 发展的桎梏，成为了 C++ 最令人诟病的部分。 当然，C 语言是一门优秀的语言，其简洁高效的特性是其他语言难以比肩的。但是在 C++ 程序里面，我们更好的做法是写 C++ 程序，或者更明确一些 —— Modern C++，而非 C with classes，尽量避免让 C++ 程序出现 Bad Smell。 正文以下几点是值得注意的： 多维数组传参以二维数组为例，典型的 C 语言传参方式是这样的： 12345void fun(int** a, size_t sz);int* arr[SIZE_ARR];for(int i=0; i&lt;SIZE_ARR; ++i) arr[i] = (int*)malloc(sizeof(int)); 这是什么意思呢？这里表示的是我们传入的其实还是一个一维数组，只是这个数组的元素恰好都是指向另一组等长的一维数组的指针。 要理解为什么参数只能传递一维数组，而不能传递高维数组，其实很简单。我们注意到函数在传入数组作为参数的时候，还需要多传一个参数说明数组长度（这在 Java/JavaScript/Python 等语言之中都是不必要的）。在获取二维数组 a[m][n] 中的元素 a[i][j] 的时候，我们需要做的就是计算 *(a+i×n+j)，也就是我们必须要知道 n 才能计算出元素地址。所以如果我们想要把二维数组作为参数传入函数的时候，只能是 fun(int a[][n], size_t n); 这种形式，但是这里的 n 显然不是我们想要展示出来的。 那么 C++ 的写法是什么呢？当然是 STL 容器了！这里根据数组长度是否可变（C99支持VLA）使用两种不同的容器来完成 —— std::array 和 std::vector。以 vector 为例： 123456789101112131415void funv(vector&lt;vector&lt;int&gt;&gt;::iterator it1, vector&lt;vector&lt;int&gt;&gt;::iterator it2)&#123; for (auto it = it1; it != it2; ++it) for (auto jt = it-&gt;begin(); jt != it-&gt;end(); ++jt) cout &lt;&lt; *jt &lt;&lt; endl;&#125;int main()&#123; //array&lt;array&lt;int, 5&gt;, 4&gt; a; vector&lt;vector&lt;int&gt;&gt; v; funv(v.begin(), v.end()); return 0;&#125; 数组上面已经展示过了，C 语言中的定长数组使用 std::array 代替，变长数组使用 std::vector 代替。下标遍历使用迭代器代替。 memsetC++ 原则之 RAII（资源获取即初始化），如： 12345678// Cint a[SIZE_A];memset(a, 0, sizeof(a));// C++array&lt;int, SIZE_A&gt; a; //array&lt;int, SIZE_A&gt; a = &#123;&#125;;a.fill(0);vector&lt;int&gt; v(SIZE_A, 0); 多维数组初始化依然使用循环赋值这一通用做法。 指针C++ 避免使用裸指针。用 auto_ptr（已废弃）、unique_ptr、shared_ptr、weak_ptr 代替。具体用法以后有机会再写。 字符串C 语言没有字符串，只有字符数组这一原始结构。C++ 前进了一步，std::string 对 char[] 进行了封装。（当然，仍然是糟糕的设计，只比 char[] 稍好一点，优良的设计可以参考 JavaScript 等语言的字符串设计）。 12345678910111213int main()&#123; string m;//to_string(n); int n; //itoa(n); cin &gt;&gt; m &gt;&gt; n; cout &lt;&lt; m &lt;&lt; ' ' &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; atol(m.c_str()) &lt;&lt; endl; cout &lt;&lt; strtol(m.c_str(), nullptr, n) &lt;&lt; endl; cout &lt;&lt; stol(m, nullptr, n) &lt;&lt; endl; string::size_type idx; cout &lt;&lt; stol(m, &amp;idx, n) &lt;&lt; ' ' &lt;&lt; idx &lt;&lt; endl; return 0;&#125; 函数指针万幸，一直弄不明白的函数指针问题终于有了解决方案 new/deleteRAII，资源获取即初始化，你值得拥有。 1234567// Cint a[3];int *b = new int[3];// C++vector&lt;int&gt; a(3); // 栈空间vector&lt;int&gt; *b = new vector&lt;int&gt;(3); //堆空间 关于选用栈空间还是堆空间的问题，还会有一篇文章来说明这个问题。 （宏替换、函数展开）危险函数 gets、fgets、友善度随着 C++ 标准的更新继续完善。 参考 C++不是C/C++ - 唐诗 - 博客园 https://bbs.avplayer.org/t/c-1-c/264 http://www.aizhuanji.com/a/0VoMRExe.html http://www.cnblogs.com/Solstice/archive/2011/07/17/2108715.html http://blog.csdn.net/sd6733531/article/details/7400202 姊妹篇Modern C++ 完","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://blogless.github.io/tags/C-C/"},{"name":"编程","slug":"编程","permalink":"http://blogless.github.io/tags/编程/"}]},{"title":"奇技淫巧之尾递归","slug":"奇技淫巧之尾递归","date":"2017-10-25T11:50:26.000Z","updated":"2019-08-25T03:09:15.724Z","comments":true,"path":"2017/10/25/奇技淫巧之尾递归/","link":"","permalink":"http://blogless.github.io/2017/10/25/奇技淫巧之尾递归/","excerpt":"","text":"引子这几天偶然看到关于尾递归的文章，联想到之前写过的斐波那契数列，干脆就单开一篇专门写一下尾递归的事，留待以后查阅。 正文什么是尾递归尾递归是一种尾调用。所谓尾调用，望文生义就是指函数的最后一步也是一个函数调用。那么尾递归也就是函数尾调用自身。 为什么要用尾递归与一般递归相比，尾递归的效率更高，其主要原因在于： 一般递归调用时需要重新开辟函数调用栈； 尾递归调用时编译器可以自动优化，直接利用原有的栈进行调用。 虽然栈的运行效率相比堆效率高很多，但减小栈的开销仍然是有意义的，尤其是在栈的开销很大的时候。 尾递归的效率提升我们可以拿之前写过的斐波那契数列做实验对比一下： 一般递归123456789long Fibonacci(long n)&#123; if (n &lt;= 0) return 0; else if (n == 1 || n == 2) return 1; else return Fibonacci(n - 1) + Fibonacci(n - 2);&#125; 尾递归1234567891011121314/** Fibonacci_tail：斐波那契数列尾递归形式 * n：待求值 * acc1：累计值1 * acc2：累计值2 */long Fibonacci_tail(long n, long acc1, long acc2)&#123; if (n &lt;= 0) return 0; else if (n == 1 || n == 2) return acc2; //acc2 else return Fibonacci_tail(n - 1, acc2, acc1 + acc2);&#125; 效率对比1234567891011121314int main()&#123; clock_t t1 = clock(); Fibonacci(20); clock_t t2 = clock(); cout &lt;&lt; t2 - t1 &lt;&lt; endl; clock_t t3 = clock(); Fibonacci_tail(20, 1, 1); clock_t t4 = clock(); cout &lt;&lt; t4 - t3 &lt;&lt; endl; return 0;&#125; 运行结果122783 可以看到，尾递归优化过的斐波那契数列，运行效率有质的提高。不仅仅是因为栈的利用率提高，而且栈的调用层次从原来的树形结构编程了朴素的线性结构，节约了大量的重复计算。如果从尾递归再进一步优化的话，马上就是迭代形式。 注意事项尾递归虽然效率比一般递归效率有提高，但是理解起来的难度也更高，因此建议在彻底弄懂之后再写尾递归代码，并且加上必要的注释。或者，直接写成迭代形式，更好理解，并且效率更高。 先能够写正确的代码，再写高效的代码。 当然，不只是 C++ 会有尾递归优化。 参考 尾递归优化 - 阮一峰的网络日志 完","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://blogless.github.io/tags/算法/"},{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"http://blogless.github.io/tags/奇技淫巧/"}]},{"title":"C++中的骚操作","slug":"C-中的骚操作","date":"2017-10-25T10:07:30.000Z","updated":"2019-09-05T11:37:58.693Z","comments":true,"path":"2017/10/25/C-中的骚操作/","link":"","permalink":"http://blogless.github.io/2017/10/25/C-中的骚操作/","excerpt":"","text":"引子这篇文章的起因是我在写程序的时候，发现总是用到这样的简单循环： 1234for(int i = 0; i &lt; n; i ++)&#123; // Do something to a[i]&#125; 当然，有时候它也可能是这种形式： 1234for(auto x: a)&#123; // Do something to x&#125; 这种循环操作中，后一次的操作与前一次的操作有时候没有必然联系，这样写也仅仅只是因为他们在同一个数组中。 然而引入临时变量总是让人不爽，我总是情不自禁回想起 python 和 JavaScript 中的 map / reduce 操作。 那么，C++ 里面有这种 map / reduce 函数吗？ 正文现代语言总是会有一些高级操作，能够极大地提高我们编写程序的效率和准确度。用惯了 map / reduce，再回来使用循环总是会让人有些不爽。所幸，我们需要的功能 STL 中已经存在了，只是平常我们没有注意到。现在我就要把它发掘出来，让他重见天日。 transform &lt;- maptransform 有两种形式： transform12345678910//unary operation(1)template &lt;class InputIterator, class OutputIterator, class UnaryOperation&gt;OutputIterator transform (InputIterator first1, InputIterator last1, OutputIterator result, UnaryOperation op);//binary operation(2)template &lt;class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation&gt;OutputIterator transform (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryOperation binary_op); 首先看一下 transform 是怎么实现的： transform12345678910&#123; while (first1 != last1) &#123; *result = op(*first1); // or: *result = binary_op(*first1, *first2++); ++result; ++first1; &#125; return result;&#125; 很简单直接，基本就是把我们手写 map 的过程抽象一下提取出模板。那我们直接上使用的例子就好了。 123int op_increase (int i) &#123; return ++i; &#125;std::transform (foo.begin(), foo.end(), bar.begin(), op_increase); 12/// std::plus adds together its two arguments:std::transform (foo.begin(), foo.end(), bar.begin(), foo.begin(), std::plus&lt;int&gt;()); 一个经典的用法是对字符串实现大小写转换： 12345678#include &lt;string&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;transform(s.begin(), s.end(), s_lower.begin(), ::tolower);transform(s.begin(), s.end(), s_upper.begin(), ::toupper);//tolower和toupper 分别在两个地方定义了：一个是 std::tolower ，一个是在 cctype中定义的。//这里使用::是为了使用cctype里面的那个。//记得给s_lower、s_upper事先 resize(s.size()) accumulate &lt;- reduceC++ 中的 accumulate 函数同样是两种形式： accumulate12345678//sum(1)template &lt;class InputIterator, class T&gt;T accumulate (InputIterator first, InputIterator last, T init);//custom(2)template &lt;class InputIterator, class T, class BinaryOperation&gt;T accumulate (InputIterator first, InputIterator last, T init, BinaryOperation binary_op); 其实现： accumulate123456789&#123; while (first != last) &#123; init = init + *first;// or: init = binary_op(init, *first); ++first; &#125; return init;&#125; 使用样例： 123456789//缺省求和std::cout &lt;&lt; std::accumulate(nums.begin(), nums.end(), init);//库函数求和std::cout &lt;&lt; std::accumulate (numbers, numbers+3, init, std::plus&lt;int&gt;());//自定义函数求和int op_plus(int a, int b) &#123; return a + b; &#125;std::cout &lt;&lt; std::accumulate (numbers, numbers+3, init, op_plus); 当然，不仅仅是求和，通过修改传入的函数参数，还可以实现求积等功能。 copy_if &lt;- filtercopy_if 是 copy 系列函数中的一个，会对被 copy 的对象进行筛选以判断是否执行copy操作。其函数原型为： copy_if123template &lt;class InputIterator, class OutputIterator, class UnaryPredicate&gt;OutputIterator copy_if (InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred); 内部实现参考： copy_if123456789101112&#123; while (first != last) &#123; if (pred(*first)) &#123; *result = *first; ++result; &#125; ++first; &#125; return result;&#125; 使用样例： 123// copy only positive numbers:auto it = std::copy_if (foo.begin(), foo.end(), bar.begin(), [](int i)&#123;return !(i&lt;0);&#125; );bar.resize(std::distance(bar.begin(),it)); // shrink container to new size 关于 lambada 表达式在传入函数参数的时候，往往作为参数的函数我们只会在函数中使用这么一次，这个时候单独定义一个全局函数是很没有必要的。在 ES6 中我们使用 箭头函数，python 有 Lambda Expressions，Java 8 也引入了 Lambda Expressions 。而 C++11 中也引入了这个现代化的特性 ——（虽然很丑但也算是） Lambda 表达式 (C++11 起) 关于 C++ lambda 表达式，以后想起来的时候还会写文章总结。 C++ 并行计算库实际上，我们还可以使用专业的并行计算库，充分利用多核性能来提高运算效率，如 Intel 的 TBB （Intel® Threading Building Blocks） 或者 Microsoft 的 PPL （Parallel Patterns Library）。具体用法可以参考 c++并行计算库TBB和PPL的基本用法 - qicosmos(江南) - 博客园 参考 transform - C++ Reference accumulate - C++ Reference copy_if - C++ Reference 完","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://blogless.github.io/tags/C-C/"},{"name":"编程","slug":"编程","permalink":"http://blogless.github.io/tags/编程/"},{"name":"STL","slug":"STL","permalink":"http://blogless.github.io/tags/STL/"}]},{"title":"或与加","slug":"或与加","date":"2017-10-21T11:18:40.000Z","updated":"2019-09-06T01:32:50.122Z","comments":true,"path":"2017/10/21/或与加/","link":"","permalink":"http://blogless.github.io/2017/10/21/或与加/","excerpt":"","text":"在 牛客网 上看到的一道题目，感觉有点意思，在这里做个记录。 题目给定 x, k ，求满足 x + y = x | y 的第 k 小的正整数 y 。 | 是二进制的或(or)运算，例如 3 | 5 = 7。比如当 x=5，k=1时返回 2，因为5+1=6 不等于 5|1=5，而 5+2=7 等于 5 | 2 = 7。 输入描述: 每组测试用例仅包含一组数据，每组数据为两个正整数 x , k。 满足 0 &lt; x , k ≤ 2,000,000,000。 输出描述: 输出一个数y。 思路第一反应是暴力，但是会超时，没关系，先看看在暴力的基础上能不能进行优化。 这里会用到一些数学知识，观察 x + y = x | y 之后我们可以得出以下结论： x + y 的长度只能是 x、y 之中的最大长度，因为 x | y 长度为 x、y 之中的最大长度； 在任意 bit 位上，x、y 不能同时取 1。 第二个结论很有意思，也是这道题的关键。在这之前我们先看一道简单题： 371. Sum of Two Integers Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. 其实就是自己设计一个加法器，这里直接给出一种答案： 123456int add(int a, int b)&#123; int t1 = a ^ b; int t2 = (a &amp; b) &lt;&lt; 1; return (t2 == 0) ? t1 : add(t1, t2);&#125; 注意看程序，如果 x、y 在任意 bit 位不同时取 1 的时候，t2 是不是就已经是 0 了？ 在这这种情况下，我们有 $$ add(a, b) == t1 == a ^ b == a | b $$ 是不是很神奇？ 可以自己简单证明一下，到底 x + y = x | y 是不是 x、y 在任意 bit 位不同时取 1 的充要条件。 有了以上结论之后，在给定 x 的情况下，求 y 能取到的值，有什么好办法了吗？ 解答由之前的思考，我们可以得出结论，只需要抽取 x 取值为 0 的位进行取值遍历就能取出所有满足条件的 y： $$ y(i)= \\begin{cases} 0 & \\text{x(i) = 1} \\\\ 0,1 & \\text{x(i) = 0} \\end{cases} $$ 这里要取的是 第 k 个满足条件的数，那么把 k 的二进制表示拆出来填充进所有 x(i)=0 的位，工作也就完成了。 贴一份讨论区里面别人注释过的代码（这里我对代码和注释进行了一些修改）： 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int main()&#123; long long x, k; cin &gt;&gt; x &gt;&gt; k; long long bitNum = 1; long long ans = 0; // 目标是把 k 的各位依次填在 x 中是 0 的位上。 // bitNum 用来移动到 x 中 0 的位置，然后把 k 的最低位放在 x 的 0 位上, // k 左移，将下一位变成最低位,bitNum 一直左移到 x 中的下一个为 0 的位上 while (k) &#123; if ((x &amp; bitNum) == 0) // x 中 bitNum 为 0 的位,用来填充k的位 &#123; ans |= (bitNum * (k &amp; 1)); // 将 k 的最低位取出来,放到在 x 的 bitNum 位上 k &gt;&gt;= 1; &#125; bitNum &lt;&lt;= 1; // bitNum 左移直到 x 中的 0 位 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 感想结合了数学的程序还是酸爽啊～ 完","categories":[{"name":"编程","slug":"programming","permalink":"http://blogless.github.io/categories/programming/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://blogless.github.io/tags/编程/"},{"name":"数学","slug":"数学","permalink":"http://blogless.github.io/tags/数学/"}]},{"title":"华为笔试题","slug":"华为笔试题","date":"2017-10-20T13:40:45.000Z","updated":"2019-08-25T03:09:15.704Z","comments":true,"path":"2017/10/20/华为笔试题/","link":"","permalink":"http://blogless.github.io/2017/10/20/华为笔试题/","excerpt":"","text":"华为笔试第三题，今天刚做过的，还热乎着呢。 题目题目大概是说： 有一种类似于 Lisp 的语言，包含 add、sub、mul、div 四中操作（均为小写），形式为 (add 2 3) 这种。其中，sub、div 的操作数只能是两个，add、mul 的操作数可以是两个以上，操作数可以为另一个表达式，也就是可以嵌套。 题目保证输入都是合法的语句，要求程序计算出最终结果并输出，弱出现 除数为零的情况，则输出 “error”。 思路前缀表达式转后缀表达式，然后求值即可。 答案我的答案是这个，仅供参考： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152// 华为校招笔试：2017-10-20// blogless.github.io// 赵恒昶#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; stack&lt;string&gt; stk; enum Opt &#123; add, sub, mul, div &#125;; stack&lt;Opt&gt; Opstk; string s; getline(cin, s); // cin &gt;&gt; s; for (int i = 0; i &lt; s.size(); i++) &#123; //cout &lt;&lt; \"s[i]:\" &lt;&lt; s[i] &lt;&lt; endl; if (s[i] == ' ') continue; switch (s[i]) &#123; case '(': &#123; stk.push(\"(\"); break; &#125; case ')': &#123; Opt op = Opstk.top(); Opstk.pop(); switch (op) &#123; case sub: &#123; long a = atol(stk.top().c_str()); stk.pop(); long b = atol(stk.top().c_str()); stk.pop(); string ans = to_string(b - a); if (stk.top() == \"(\") &#123; stk.pop(); stk.push(ans); &#125; break; &#125; case div: &#123; long a = atol(stk.top().c_str()); stk.pop(); long b = atol(stk.top().c_str()); stk.pop(); if (a == 0) &#123; cout &lt;&lt; \"error\" &lt;&lt; endl; return 0; &#125; string ans = to_string(b / a); if (stk.top() == \"(\") &#123; stk.pop(); stk.push(ans); &#125; break; &#125; case add: &#123; long ans = 0; while (stk.top() != \"(\") &#123; ans += atol(stk.top().c_str()); stk.pop(); &#125; stk.pop(); stk.push(to_string(ans)); break; &#125; case mul: &#123; long ans = 1; while (stk.top() != \"(\") &#123; ans *= atol(stk.top().c_str()); stk.pop(); &#125; stk.pop(); stk.push(to_string(ans)); &#125; break; &#125; break; &#125; case 'a': &#123; i += 2; //add Opstk.push(add); //cout &lt;&lt; \"add-s[i]: \" &lt;&lt; s[i] &lt;&lt; endl; break; &#125; case 's': &#123; i += 2; //sub Opstk.push(sub); break; &#125; case 'm': &#123; i += 2; //mul Opstk.push(mul); break; &#125; case 'd': &#123; i += 2; //div Opstk.push(div); break; &#125; default: &#123; bool neg = false; if (s[i] == '-') &#123; neg = true; i++; &#125; long t = s[i] - '0'; while (isdigit(s[++i])) t = t * 10 + s[i] - '0'; if (neg) t = -t; stk.push(to_string(t)); i--; //cout &lt;&lt; \"num:\" &lt;&lt; t &lt;&lt; endl; break; &#125; &#125; &#125; cout &lt;&lt; stk.top() &lt;&lt; endl; return 0;&#125; 完","categories":[{"name":"编程","slug":"programming","permalink":"http://blogless.github.io/categories/programming/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://blogless.github.io/tags/C-C/"},{"name":"编程","slug":"编程","permalink":"http://blogless.github.io/tags/编程/"}]},{"title":"Hexo博客插入数学公式","slug":"Hexo博客插入数学公式","date":"2017-10-18T04:37:16.000Z","updated":"2019-09-06T01:24:58.982Z","comments":true,"path":"2017/10/18/Hexo博客插入数学公式/","link":"","permalink":"http://blogless.github.io/2017/10/18/Hexo博客插入数学公式/","excerpt":"","text":"引言之前写 华为面试记（三） 的时候，用到了矩阵和数列，因此需要在博客中插入公式。抽空研究了一下，发现 Hexo 可以很方便地使用 MathJax 来插入数学公式，这里简单记录一下使用方法。 正文本文分两部分，一部分讲怎么使用 MathJax 作为 Hexo 博客的公式编辑器，另一部分讲 LaTex 公式语法。 MathJax 的使用方法一：博文中启用 MathJax紧跟文档头部元数据之后，嵌入 html 语句： 123&lt;script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt; 优点是按需插入，不需要插入公式的文档就不进行 MathJax 渲染，提高网页速度。 缺点是博文中插入了内容无关信息。 方法二：用 _config.yml 配置修改主题目录下的 _config.yml 文件，改动如下： /themes/indigo/_config.yml123mathjax: enable: true cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML 优点是不用在博文中加入过多无关信息。 缺点是可能每个页面都渲染，影响访问速度。 这里我使用的是第二种方案。 总之，现在 MathJax 编辑器就能使用了。 插入公式的时候，如果是插入行内，需要使用 \\(公式\\) 或者 $公式$ 这种形式；如果是插入单行公式，则需要使用 \\[公式\\] 或者 $$公式$$ 这种形式。（在输入这个$符号的时候，为了不被 MathJax 识别为公式进行渲染，我用 ` 把它引用了起来。） 当然，使用 MathJax 插入公式也可以先在 MathJax官网 上输入公式预览效果，然后插入文档使用，它可以帮你检查语法错误。 LaTex 语法大括号双\\公式内换行，cases实现大括号右多行赋值，&amp;用来对齐 但是这里公式换行需要三个｜，原因后面会解释 斐波那契数列12345678$$F(n)= \\begin&#123;cases&#125; 1 &amp; \\text&#123;n = 1&#125; \\\\ 1 &amp; \\text&#123;n = 2&#125; \\\\ F(n-1)+F(n-2) &amp; \\text&#123;n&gt;2&#125; \\end&#123;cases&#125;$$ $$ F(n)= \\begin{cases} 1 & \\text{n = 1} \\\\ 1 & \\text{n = 2} \\\\ F(n-1)+F(n-2) & \\text{n>2} \\end{cases} $$ 角标^ 表示上标，_表示下标。如果上下标的内容多于一个字符，要用{}把这些内容括起来当成一个整体。上下标是可以嵌套的，也可以同时使用。 另外，如果要在左右两边都有上下标，可以用 \\sideset 命令。 矩阵12345$$ \\begin&#123;pmatrix&#125; 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end&#123;pmatrix&#125; \\begin&#123;bmatrix&#125; 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end&#123;bmatrix&#125; \\begin&#123;vmatrix&#125; 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end&#123;vmatrix&#125;$$ $$ \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\\\ \\end{pmatrix} \\begin{bmatrix} 1 & 2 \\\\ 3 & 4 \\\\ \\end{bmatrix} \\begin{vmatrix} 1 & 2 \\\\ 3 & 4 \\\\ \\end{vmatrix} $$ Markdown 与 MathJax 语法冲突换行MathJax 语法中的换行应该是 \\\\，然而由于第一个 \\ 会被 markdown 解析成转义符，也就相当于只剩下了一个 \\，所以有时会使用 \\\\\\，三个反斜线来表示换行。 下标_ 是 MathJax 语法中的下标连接符，但是在 markdown 语法中，两个 _ 中间的文字会被解析成斜体，需要使用 \\ 进行转义，留下 _ 给 MathJax。也就是说，在公式中有时需要使用_ 的地方改用 \\_。 通用解决方案方法一上文已述，使用转义字符，不提倡 方法二手动escape，添加到博文之中，或者修改 js 渲染脚本： /nodes_modules/marked/lib/marked.js1234567//escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()# +\\-.!_&gt;])/,escape: /^\\\\([`*&#123;&#125;\\[\\]()# +\\-.!_&gt;])/,//去掉\\\\转义//em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,//去掉_的斜体含义 这种方式可能造成其它的字符会冲突，暂时将就着用，以后随时修改。 方法三还有一种方法是用 {% raw %}$ 公式 ${% endraw %} 这种形式，即使用 {% raw %}$` 和 `${% endraw %} 把行内代码包起来，不让 markdown 渲染器对公式内部进行渲染。（这里为了打出来这两个标签而不让标签生效，我多打了一遍，让外层的标签起作用，这样就只显示内层标签了） 这种方法比前两种要好。 方法四发现了一个 Markdown+Math 插件，可以在 VSCode 里面直接预览 markdown 中的 Latex 公式，不过这个插件还有一些小限制（比如行内公式的 $ 与公式之间不能有空格）。 使用这个插件的话，必须使用纯粹的 Latex 语法，不能用 {% raw %} {% endraw %} 这种多余的符号（这当然更好，博文更纯粹），当然也就要求我们需要对 Hexo 中的 MathJax 渲染问题重新进行配置。 简单粗暴一步到位的方法 —— 更换渲染器： 1234567891011# 在主题_config.yml 中配置mathjax: true# 要先卸载已有的渲染器npm uninstall hexo-renderer-marked --save# 卸载已经不再维护的 hexo-math 插件npm uninstall hexo-math --save# 先安装好 pandoc，然后执行如下命令npm install hexo-renderer-pandoc --save 方法五公式显示错乱的本质在于：Latex公式在被mathjax处理之前，被markdown多余处理了一遍。所以我们可以想办法让latex公式绕过markdown的处理。由于大多数markdown渲染器都支持html标签，以此来补足markdown排版短板，我们可以在公式外用一对&lt;div&gt;&lt;/div&gt;包裹起来，以达到这个效果。此外还可以使用&lt;p&gt;&lt;/p&gt;，但是不能使用&lt;span&gt;&lt;/span&gt;。另外需要注意的是，代码块标签前后要加空行。 行内公式怎么处理？和文字一起，整行包起来就可以了。 当然，这个方案还有一点小问题，那就是行内公式坐在行还有其他markdown格式符存在的时候怎么办。我的建议是把公式部分拆一行没有格式的出来。 参考 MathJax使用LaTeX语法编写数学公式教程 - 作业部落 Markdown写作进阶：Pandoc入门浅谈 - 阳志平的网志 Q&amp;A：科学写作中的基本工具和用法 | 浚宇的博客 Hexo实现Math公式撰写的实验报告 | 浚宇的博客 友善度用到再随时补充。 完","categories":[{"name":"实用工具","slug":"tools","permalink":"http://blogless.github.io/categories/tools/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://blogless.github.io/tags/博客/"},{"name":"Markdown","slug":"Markdown","permalink":"http://blogless.github.io/tags/Markdown/"},{"name":"MathJax","slug":"MathJax","permalink":"http://blogless.github.io/tags/MathJax/"}]},{"title":"华为面试记（三）","slug":"华为面试记（三）","date":"2017-10-17T05:54:55.000Z","updated":"2019-09-06T01:30:04.915Z","comments":true,"path":"2017/10/17/华为面试记（三）/","link":"","permalink":"http://blogless.github.io/2017/10/17/华为面试记（三）/","excerpt":"","text":"—— 斐波那契数列 引子技术面的面试官让我手写了一个斐波那契数列。在跟面试官确认之后我用迭代的方法写了这道题。（我明明记得斐波那契数列有一个通项公式的，还跟面试官问了一下这种解法，面试官竟然一脸懵逼，是考察点不是这个还是怎么的…… 我跟面试官征求了一下利用数组缓存数据的优化方案，面试官根本不在乎这一点优化 2333 斐波那契数列题目描述： $$ F(n)= \\begin{cases} 1 & \\text{n = 1} \\\\ 1 & \\text{n = 2} \\\\ F(n-1)+F(n-2) & \\text{n>2} \\end{cases} $$ 递归解法毫无技术含量的递归解法，虽然时空效率不高，但足够简单粗暴，可以用来启发思路。 面试官曾经说过，递归转迭代是必备基本技能。 直接上代码： 123456789unsigned long Fibonacci(unsigned int n)&#123; if (n &lt;= 0) return 0; else if (n == 1 || n == 2) return 1; else return Fibonacci(n - 1) + Fibonacci(n - 2);&#125; 注：这里还能优化，详见 奇技淫巧之尾递归 迭代解法显然，递归解法里面存在着大量不必要的重复计算，这里给出迭代解法： 123456789101112131415161718192021unsigned long Fibonacci(unsigned int n)&#123; if (n &lt;= 0) return 0; else if (n == 1 || n == 2) return 1; else &#123; unsigned long ans; unsigned long a = 1, b = 1; unsigned long i = 3; while (i &lt;= n) &#123; ans = a + b; b = a; a = ans; i++; &#125; return ans; &#125;&#125; 算法时间复杂度O(n)，空间复杂度O(1)。 矩阵解法首先给出公式： $$ \\begin{bmatrix} f(n) & f(n-1) \\\\ f(n-1) & f(n-2) \\end{bmatrix} = {\\begin{bmatrix} 0 & 1 \\\\ 1 & 1 \\end{bmatrix}} ^ {n-1} $$ 证明方法很简单，数学归纳即可。 至于这种想法怎么来的，方程组不都喜欢用矩阵解嘛 ╮(╯_╰)╭ 直接上程序，没什么可说的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//定义2×2矩阵；class Matrix2by2&#123; public: long m00, m01; long m10, m11; Matrix2by2(long m_00 = 1, long m_01 = 0, long m_10 = 1, long m_11 = 0) : m00(m_00), m01(m_01), m10(m_10), m11(m_11) &#123; &#125; Matrix2by2(const Matrix2by2 &amp;mx) : m00(mx.m00), m01(mx.m01), m10(mx.m10), m11(mx.m11) &#123; &#125; Matrix2by2 matrixMultiply(const Matrix2by2 &amp;matrix); Matrix2by2 matrixPower(unsigned int n);&#125;;//定义2×2矩阵的乘法运算Matrix2by2 Matrix2by2::matrixMultiply(const Matrix2by2 &amp;matrix)&#123; Matrix2by2 product(*this); product.m00 = this-&gt;m00 * matrix.m00 + this-&gt;m01 * matrix.m10; product.m01 = this-&gt;m00 * matrix.m01 + this-&gt;m01 * matrix.m11; product.m10 = this-&gt;m10 * matrix.m00 + this-&gt;m11 * matrix.m10; product.m11 = this-&gt;m10 * matrix.m01 + this-&gt;m11 * matrix.m11; return product;&#125;//定义2×2矩阵的幂运算Matrix2by2 Matrix2by2::matrixPower(unsigned int n)&#123; Matrix2by2 matrix(1, 0, 1, 0); // I if (n == 1) &#123; matrix = Matrix2by2(*this); &#125; else if (n % 2 == 0) &#123; matrix = this-&gt;matrixPower(n / 2); matrix = matrix.matrixMultiply(matrix); &#125; else if (n % 2 == 1) &#123; matrix = this-&gt;matrixPower((n - 1) / 2); matrix = matrix.matrixMultiply(matrix); matrix = matrix.matrixMultiply(Matrix2by2(*this)); &#125; return matrix;&#125;//计算Fibnacci的第n项long Fibonacci(unsigned int n)&#123; if (n &lt;= 0) return 0; if (n == 0 || n == 1) return 1; Matrix2by2 matrix(1, 1, 1, 0); Matrix2by2 fibMatrix = matrix.matrixPower(n - 1); return fibMatrix.m00;&#125; 通项公式首先给出通项公式： $$ a_n = \\frac{1}{\\sqrt{5}} [ (\\frac{1+\\sqrt{5}}{2}) ^ n - (\\frac{1-\\sqrt{5}}{2}) ^ n ] $$ 下面给出证明。 这里用到了高中学过的数列的知识： 由 $a_{n+2}=a_{n+1}+a_{n}$ 可得： $a_{n+2} - \\frac{1-\\sqrt{5}}{2}a_{n+1} = \\frac{1+\\sqrt{5}}{2} ( a_{n+1} - \\frac{1-\\sqrt{5}}{2}a_{n} )$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （１） $a_{n+2} - \\frac{1+\\sqrt{5}}{2}a_{n+1} = \\frac{1-\\sqrt{5}}{2} ( a_{n+1} - \\frac{1+\\sqrt{5}}{2}a_{n} )$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （２） 由（１）（２）得： $a_{n+2} - \\frac{1-\\sqrt{5}}{2}a_{n+1} = (\\frac{1+\\sqrt{5}}{2})^n * A$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （３） $a_{n+2} - \\frac{1+\\sqrt{5}}{2}a_{n+1} = (\\frac{1-\\sqrt{5}}{2})^n * B$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （４） 其中 Ａ、Ｂ 为待定常数，由 $a_1$、$a_2$ 确定 由（３）（４）得： $$ a_{n+2} = (\\frac{1-\\sqrt{5}}{2})^n * C + (\\frac{1+\\sqrt{5}}{2})^n * D $$ 其中 C、D 为待定常数，由 $a_1$、$a_2$ 确定 解得： $$ a_n = \\frac{1}{\\sqrt{5}} [ (\\frac{1+\\sqrt{5}}{2}) ^ n - (\\frac{1-\\sqrt{5}}{2}) ^ n ] , n > 2 $$ 验证一下，$a_1$、$a_2$ 也符合通项公式。 当然，利用前面的矩阵也可以推算出数列的通项公式。 不过通项公式很麻烦的一点是，你怎么在程序里面把 $\\sqrt{5}$ 不损失精度地进行计算，因为通项公式虽然包含 $\\sqrt{5}$ 但是最终值是一个确定无疑的整数。我觉得这需要一个专业的数学库来计算。 更多解法可以参考知乎里面的讨论。 参考 【算法02】3种方法求解斐波那契数列- python27 - 博客园 斐波那契数列通项公式是怎样推导出来的？ -知乎 完","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://blogless.github.io/tags/C-C/"},{"name":"面试","slug":"面试","permalink":"http://blogless.github.io/tags/面试/"}]},{"title":"华为面试记（二）","slug":"华为面试记（二）","date":"2017-10-17T00:53:57.000Z","updated":"2019-09-06T01:17:58.783Z","comments":true,"path":"2017/10/17/华为面试记（二）/","link":"","permalink":"http://blogless.github.io/2017/10/17/华为面试记（二）/","excerpt":"","text":"—— 虚函数与成员函数 引子华为技术面的面试官问了我一个问题，“C++里面多态是怎么实现的？” 我当时只答出来说是函数重载，面试官显然对这个答案并不满意，提示我说 “虚函数表”，emmmm …… 刚好我在论坛里面也看到了这么一道题，那就在这里整理一下，也算纪念一下昨天下午的面试吧。 正文这两段代码的执行结果是什么，为什么？ 代码一1234567891011121314#include &lt;stdio.h&gt;class A&#123; public: A()&#123;&#125;; virtual void funa()&#123; printf(\"hello\\n\"); &#125;&#125;;int main()&#123; A *a = NULL; a-&gt;funa();&#125; 代码二1234567891011121314#include &lt;stdio.h&gt;class A&#123; public: A()&#123;&#125;; void funa()&#123; printf(\"hello\\n\"); &#125;&#125;;int main()&#123; A *a = NULL; a-&gt;funa();&#125; （据说这是腾讯的面试题） 我们看一下，这两段代码的区别是什么呢？只有一点，那就是funa是虚函数还是普通成员函数。问题的另一个关键之处是什么呢，是调用者都是NULL！把握了这两点，基本上答案就呼之欲出了。（所以说大厂校招都是考基础的！ 虚函数的调用在上面的例子中，我们对 A 取一下 sizeof 就会发现，代码二中的 sizeof(A) 是 1，而代码一中的 sizeof(A) 是 8（x64环境下）。 ps：可以想想为什么代码二中的 sizeof(A) 是 1 而不是 0 sizeof 访问的是数据段，A 没有任何成员变量，那么这个 8 字节的空间开销是哪里来的呢？就是虚函数表！vptr占用8个字节，指向虚函数表的位置（如图1所示）。没有虚函数的类自然就省去了这部分开jpg销。 华为面试记（二）_图一.png 虚函数在内存空间也是只有一份的，但是在继承过程中，没有被重写（override）的虚函数会共享父类的虚函数，也就是节约了一份函数开销（如图二所示）。 华为面试记（二）_图二.png 多继承呢？多个虚函数表呗。 纯虚函数呢？与虚函数的区别仅仅是虚函数没有函数体，而 vtbl 仍然是存在的（参考Java中的接口（Interface）这一概念）。 普通成员函数、静态成员函数类的普通成员函数、静态成员函数是不占用类内存的(所有的函数都是放在代码段的，不管是全局函数还是成员函数)。 普通成员函数的实现和普通的全局函数一样，只不过比全局函数多传入了一个参数，也就是这个对象的指针（有没有想到python里面那个self？？）。实际上，编译器在实现的时候就是这么做的，A::fun(int,int) 会被编译成 fun_A*_int_int()，知道了这个，函数重载很多特性就都很容易理解了。 静态成员函数不属于某个对象，比普通的成员函数少了一个 this 指针，因而不能访问非静态成员但可以不生成对象来使用（毕竟都编译成普通全局函数了）。 回到题目中现在题目清楚了：NULL 对象能不能访问虚函数？能不能访问普通成员函数？ 因为普通成员函数的调用者在编译期就确定了，在没有访问成员变量的情况下，NULL 对象也可以编译运行（和普通的全局函数没有区别）。但是如果改造一下就不能了： 代码二12345678910111213141516171819#include &lt;stdio.h&gt;class A&#123; int a; public: A()&#123;&#125;; void funa() &#123; a++; printf(\"hello\\n\"); &#125;&#125;;int main()&#123; A *a = NULL; a-&gt;funa();&#125; 此时，NULL 对象访问成员变量会出错。 而虚函数的调用者需要在运行期动态绑定，NULL 对象并不能找到虚函数表，自然无法正常运行。 延伸以下两段代码输出一样吗？为什么？ 12345678910111213141516171819#include &lt;stdio.h&gt;class A&#123; public: A()&#123;&#125;; virtual void fun() &#123; printf(\"hello\\n\"); &#125;&#125;;class B : public A&#123; public: virtual void fun() &#123; printf(\"world\\n\"); &#125;&#125;;int main()&#123; A *b = new B; b-&gt;fun();&#125; 12345678910111213141516171819#include &lt;stdio.h&gt;class A&#123; public: A()&#123;&#125;; void fun() &#123; printf(\"hello\\n\"); &#125;&#125;;class B : public A&#123; public: void fun() &#123; printf(\"world\\n\"); &#125;&#125;;int main()&#123; A *b = new B; b-&gt;fun();&#125; 参考 C++虚函数与虚函数表 - Hakunamatata- - 博客园 C++虚函数表剖析 - Leo的博客 - CSDN博客 C++虚函数表分析 - Jim’sBlog - 博客园","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://blogless.github.io/tags/C-C/"},{"name":"面试","slug":"面试","permalink":"http://blogless.github.io/tags/面试/"}]},{"title":"华为面试记（一）","slug":"华为面试记（一）","date":"2017-10-17T00:30:13.000Z","updated":"2019-08-25T03:09:15.708Z","comments":true,"path":"2017/10/17/华为面试记（一）/","link":"","permalink":"http://blogless.github.io/2017/10/17/华为面试记（一）/","excerpt":"","text":"毫无准备，兵荒马乱地就上了战场，第一战就是华为，还真是莫大的勇气。 网申之后三天收到在线测评通知，次日收到面试通知，次周一下午，面试。 技术面的面试官是非常和蔼的一个人，耐心看了我那苍白的简历，并试图从中挖掘出任何有价值的项目经历。 是的，项目经历，项目经历，项目经历！重要的事情说三遍。 在耐心听完我的介绍之后，开始问我一些计算机基础知识。 为什么是计算机基础知识？因为这是校招，对于本科生来讲，只有基础知识是最合适的考察标准，专业技能都是要在进公司之后培训的，越是大厂越是如此。当然，如果是社会招聘的话，对不起，面试官只想知道你现在能干什么活儿。所以说，校招进一个靠谱的公司很重要，无论你是想一直在一家干下去还是有中途跳槽的心理准备！ 专业面大概进行了一个小时，一路被面试官按在地上打。之后出来等了一个半小时（？！！）才又叫到我去综合面，这次只持续了三四十分钟的样子。 说起来综合面真是无所不问，看似闲聊，但总会随时抓住你的漏洞打断你进行追问。尴尬，老底被扒得精光…… 有趣的是，综合面的面试官告诉我说他们的网络是 64k 的网络，通网络不久，数据库什么的也只有少数部门用，23333，也不知是真是假。 不过总算是完事了，既没有想象的那么恐怖（主要是面试官态度都挺好），也没有很容易（这个主要是自己太水）。总之，两周之后见结果吧！","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://blogless.github.io/tags/C-C/"},{"name":"面试","slug":"面试","permalink":"http://blogless.github.io/tags/面试/"}]},{"title":"一行脚本搭建局域网服务器","slug":"一行脚本搭建局域网服务器","date":"2017-10-06T01:32:22.000Z","updated":"2019-08-25T03:09:15.696Z","comments":true,"path":"2017/10/06/一行脚本搭建局域网服务器/","link":"","permalink":"http://blogless.github.io/2017/10/06/一行脚本搭建局域网服务器/","excerpt":"","text":"动机 在电脑上安装的 QQ、微信，一个很重要的功能就是文件传输。当我们需要在电脑和手机之间传输文件的时候，用这种即时通讯工具来传输的做法可谓是深入人心。但是，QQ、微信传输文件也有一些局限性，比如”文件过大无法传输“、”上传下载速度太慢“这些（差点忘了，还可以通过邮件附件传送文件，这种也有大小限制）。对于文件过大，很多人的第一反应是换用百度网盘，先上传云盘然后发送云盘链接，那么很快他们就会遇到第二个问题了（笑）。百度网盘现在是限速的，尽管总有很多奇技淫巧可以绕过这个限制，但是对于伸手党（此处无贬义）来讲，还是太麻烦了。这里，我们借助 Python 提供的工具，来打破文件传输困局。 正文首先需要说明的是，我们这里搭建的是 局域网http服务器，只能用于同一局域网内部的文件传输。也就是说，你的电脑和手机要连入同一个路由器。有人组建路由器网络的话，能不能用？我不知道，我相信会组建路由器网络的人自己就能弄明白这个问题的（试了一下，好像不能）。 Windows 用户需要两步：安装 python 和 打开服务器。Linux 用户和 macOS 用户请直接进入第二步。 安装 python点击进入官网，选择下载 python 2.x 或者 python 3.x 的版本都可以，我在下文分别对其做了说明。下载完成后，一路下一步完成安装。哦，对，还得记下来你的安装路径，然后添加到环境变量里才行（摔！ Linux 和 macOS 是自带 python 2.x 运行环境的，如果你是开发人员的话，你可能还装有 python 3.x 版本。 一行命令开启服务器（终于进入正题了）进入需要分享的文件所在目录，然后 Windows 用户：右键打开 cmd / Powershell / git bash，（随便挑一个，有哪个用哪个） Linux / macOS 用户：右键打开 terminal 输入 Python 命令： 12# python2 的用法：$ python -m SimpleHTTPServer &lt;port&gt; 12# python3 的用法：$ python3 -m http.server &lt;port&gt; 其中 port 可以不用填写，默认是 8000。 在本机访问 http://localhost:8000 ， 会列出该目录下的所有文件； 查看 “服务器”(当前电脑) 在局域网的 ip 地址： Windows 命令是 ipconfig Linux 命令是 ifconfig 从所给地址中找到当前无线网地址，假设是 192.168.1.3 ， 在“客户端”（手机浏览器）输入 http://ip:port （比如 192.168.1.3:8000）即可访问“服务器”目录下的文件； 注意，如果目录下有 index.html 文件的话，则显示的不是文件列表而是 index.html 的内容。 补充说明当然，传输文件的方法太多了，不一定要用这种。其他的一些，比如有的邮箱会有【文件中转站】【网络硬盘】这些附加功能，可以用来传输文件；微软有个 OneDrive 也可以存文件；通过 手机安装 ES文件管理器，或者 AirDroid 这些软件，也都可以传输文件。 那么，这种搭建局域网服务器的优势是什么呢？ 没有账户登录的操作， 省去了上传这一步， 不用安装任何软件（骗人，明明需要安装python 当然，这种方案也有劣势： 很多人根本不会操作命令行， 不知道环境变量是什么东西， 没有遇到问题随手搜索的习惯。 感想Windows 小白用户看看热闹就好。 干货12345# python2 的用法：$ python -m SimpleHTTPServer &lt;port&gt;# python3 的用法：$ python3 -m http.server &lt;port&gt; 12345# Windows 命令查看局域网地址$ ipconfig# Linux 命令查看局域网地址$ ifconfig 友善度不管你能不能用，反正我是能用的（deepin 15.4.1 + Win7） 完","categories":[{"name":"实用工具","slug":"tools","permalink":"http://blogless.github.io/categories/tools/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blogless.github.io/tags/Python/"},{"name":"服务器","slug":"服务器","permalink":"http://blogless.github.io/tags/服务器/"}]},{"title":"Mysql常用操作","slug":"Mysql常用操作","date":"2017-10-05T09:41:37.000Z","updated":"2019-09-05T11:44:35.678Z","comments":true,"path":"2017/10/05/Mysql常用操作/","link":"","permalink":"http://blogless.github.io/2017/10/05/Mysql常用操作/","excerpt":"","text":"动机 上一篇写 C API 操作 Mysql 的时候，本来打算简单陈列一下常用 Mysql 命令，结果发现篇幅太长，于是摘出来单独写了这篇 Mysql 常用操作总结。 干货这里只简单陈列一下 个人在私人数据库上 的常用操作： 说明一下，下面用&lt;&gt;包括起来的内容是操作时需要替换的部分，但是在含有sql脚本的语句中被替换成了【】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 登入/登出mysql -u &lt;用户名&gt; -p # 登录 mysql，自己一个人用的话用户名 root 就行，下一行需要输入密码quit # 退出 mysqexit # 退出 mysq^C # 退出 mysql# 系统信息select user(); # 查看当前用户select version(); # 查看当前数据库版本show variables like 'collation_%'; # 查看当前使用的字符集show character set; # 查看可以支持的字符集alter database &lt;表名称&gt; character set utf-8; # 修改数据库的字符集# 数据库操作create database &lt;新数据库名称&gt;; # 创建数据库show databases; # 显示所有数据库use &lt;数据库名称&gt;； # 进入数据库drop &lt;数据库名称&gt;； # 删除数据库# 表操作create table &lt;新表名称&gt;( &lt;字段1&gt;&lt;数据类型1&gt;, &lt;字段2&gt;&lt;数据类型2&gt;, ... ); # 创建表show tables; # 显示所有表# 表内操作descbile &lt;表名称&gt;; # 显示表的数据结构select * from &lt;表名称&gt;; # 显示表内容insert into &lt;表名称&gt; [(&lt;字段1&gt;，&lt;字段2&gt;,&lt;字段3&gt;)] values (&lt;值1&gt;，&lt;值2&gt;，&lt;值3&gt;); # 向表内添加数据update &lt;表名称&gt; set &lt;字段1&gt; = &lt;新值1&gt;，&lt;字段2&gt; = &lt;新值2&gt; where &lt;字段x&gt; = &lt;新值x&gt;; # 更新表中字段delete from &lt;表名称&gt; where &lt;条件筛选&gt;; # 删除指定记录delete from &lt;表名称&gt;； # 删除整个表# 表结构的修改alter table &lt;旧表名&gt; rename to &lt;新表名&gt;; # 修改表名alter table &lt;表名称&gt; add primary key(&lt;字段名称&gt;); # 把某个字段设置为主键alter table &lt;表名称&gt; drop primary key(&lt;字段名称&gt;); # 把某个字段删除主键定义alter table &lt;表名称&gt; add &lt;字段名称&gt; &lt;数据类型&gt;; # 增加字段并规定数据类型alter table &lt;表名称&gt; drop &lt;字段名称&gt;; # 删除字段alter table &lt;表名称&gt; modify &lt;字段名称&gt; &lt;数据类型&gt; [not null]; # 修改字段属性alter table &lt;表名称&gt; change &lt;旧字段名称&gt; &lt;新字段名称&gt; &lt;数据类型&gt;; # 修改字段名create table &lt;旧表名称&gt; like &lt;旧表名称&gt;; # 用旧表的架构建立一个新的空表# I/O 操作mysql &lt; a.sql # 对当前数据库执行外部脚本mysql 【表名称】 &lt; a.sql # 对指定数据库执行外部脚本load data local infile \"&lt;文件名&gt;\" into &lt;表名称&gt;; # 数据传入 注意，大部分 mysql 操作命令都是以“;”（或者“\\g”）结尾的，这一点与 C 语言是一致的；少部分不能加”;“，比如执行外部脚本和备份数据库这种。 友善度博主水平有限，记录的内容难免有所疏漏和不足，欢迎评论补充 ～ 完","categories":[{"name":"数据库","slug":"sql","permalink":"http://blogless.github.io/categories/sql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://blogless.github.io/tags/Mysql/"}]},{"title":"C++ 操作 Mysql","slug":"C-操作-Mysql","date":"2017-10-05T08:24:07.000Z","updated":"2019-08-25T03:09:15.660Z","comments":true,"path":"2017/10/05/C-操作-Mysql/","link":"","permalink":"http://blogless.github.io/2017/10/05/C-操作-Mysql/","excerpt":"","text":"动机 写 C++ 的时候，突然想到，以前都是在用 php 操作 Mysql，那用 C/C++ 操作 Mysql 是怎样的一种体验呢？（笑当然，php 操作 Mysql 是最舒服的，可是我就是想用 C 来操作试试。实际上，C API 才是最不可或缺的 API，其他的 API 可能很多都是 C API 的包装。 那就开始吧！ 我是在 deepin 15.4.1 上完成的操作，其他 Linux 环境请自行摸索。 安装 Mysql必备组件的包括： mysql-client，用来连接 mysql 数据库并发起操作请求 mysql-server，响应 Mysql 操作请求并返回结果 mysql-devel，库和包含文件，我们需要的头文件和动态连接库就在这里面；在 debian 系，它的名字叫 libmysqld-dev（好像 Redhat 系的 -devel 在 Ubuntu 系都叫 -dev）。 安装好上面3个包，我们就可以开心地使用 Mysql 数据库了。 建立所需数据库首先我们尝试建立一个测试用的数据库，这里简单陈列一下常用操作，写完发现太长了，我决定单开一篇整理 Mysql 操作。 总之，我假设你已经自己建立起了一个数据库 test，里面包括一个表 samples，其数据结构如下： 1234567+---------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------+-------------+------+-----+---------+-------+| name | varchar(40) | NO | | NULL | || country | varchar(40) | NO | | NULL | || number | int(11) | NO | | NULL | |+---------+-------------+------+-----+---------+-------+ 假定你已经在 samples 里面存放了几个数据。我的 samples 所含数据如下： elect * from samples; 123456789101112+-----------+---------+--------+| name | country | number |+-----------+---------+--------+| Beijing | China | 1 || Shanghai | China | 2 || Shenzhen | China | 3 || Guangzhou | China | 4 || Hangzhou | China | 5 || Nanjing | China | 6 || Wuhan | China | 7 || Chongqing | China | 8 |+-----------+---------+--------+ 现在，我们已经有了可以用的数据库，接下来就是我们真正需要的用 C 来访问 Mysql 了。 C 程序编写这里直接贴上我的测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include \"/usr/include/mysql/mysql.h\" // mysql.h 所在路径// 【编译】时需要加上 -lmysqlclient 选项 // 运行时所需动态库int main()&#123; const char user[] = \"root\"; //username const char pswd[] = \"休想！\"; //password const char host[] = \"localhost\"; //or\"127.0.0.1\" const char database[] = \"test\"; //database unsigned int port = 3306; //server port MYSQL mysql; MYSQL_RES *result = NULL; MYSQL_FIELD *fd; MYSQL_ROW sql_row; char column[32][32]; //初始化MYSQL变量 mysql_init(&amp;mysql); //连接Mysql服务器 if (!mysql_real_connect(&amp;mysql, host, user, pswd, database, port, NULL, 0)) &#123; printf(\"mysql_real_connect failed!\\n\"); return 0; &#125; // mysql_query(&amp;mysql, \"SET NAMES GBK\"); //cmd下需设置编码格式 //查询当前数据库中的samples表 if (mysql_query(&amp;mysql, \"select * from samples\")) &#123; printf(\"mysql_query failed!\\n\"); return 0; &#125; //保存查询到的数据到result result = mysql_store_result(&amp;mysql); if (result == NULL) &#123; printf(\"mysql_store_result failed!\\n\"); return 0; &#125; int num_rows = (unsigned long)mysql_num_rows(result); printf(\"number of result: %d\\n\", num_rows); for (int i = 0; fd = mysql_fetch_field(result); i++) //获取列名 &#123; strcpy(column[i], fd-&gt;name); &#125; int num_cols = mysql_num_fields(result); for (int i = 0; i &lt; num_cols; i++) &#123; printf(\"%-10s\\t\", column[i]); &#125; printf(\"\\n\"); while (sql_row = mysql_fetch_row(result)) //获取具体的数据 &#123; for (int i = 0; i &lt; num_cols; i++) &#123; printf(\"%-10s\\t\", sql_row[i]); &#125; printf(\"\\n\"); &#125; mysql_free_result(result); //释放结果资源 mysql_close(&amp;mysql); //断开连接 return 0;&#125; 干货干货？不存在的！只要去查 Mysql 的 C API 就完了。哪里不会 Google 哪里～ 友善度博主现在还是学生，根本没有在生产环境下实操过，水平有限，所以记录的内容难免有所疏漏和不足，欢迎评论补充 ～ 完","categories":[{"name":"数据库","slug":"sql","permalink":"http://blogless.github.io/categories/sql/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://blogless.github.io/tags/C-C/"},{"name":"Mysql","slug":"Mysql","permalink":"http://blogless.github.io/tags/Mysql/"}]},{"title":"使用 hexo 搭建 github 博客","slug":"setup-blog","date":"2017-10-05T02:01:55.000Z","updated":"2019-09-06T01:24:51.130Z","comments":true,"path":"2017/10/05/setup-blog/","link":"","permalink":"http://blogless.github.io/2017/10/05/setup-blog/","excerpt":"","text":"动机 搭建一个属于自己的博客的想法由来已久，可是直到现在我才动手。这里面的原因当然很多，不过最重要的原因当然还是懒（&gt;.&lt;）。一来自己还没有固定的居所，想要自己本地建站还不稳定；二来嘛，则是平常没什么功夫去写博客，写个文章还要想着美工什么的实在让人心烦。不过现在这些都不是问题了，可以把博客架在云上，也有时间操弄自己的博客了。现在暂时还是先把博客放在 github 上，以后可能考虑会放到 阿里云 上（谁知道什么时候才会动手……）。 建站方案选择当然是先要在 全球最大的同性社交网站 github 建一个主页了！ github pages 是必须要的，官方给了一个建站方案是 jekyll，当然我也首先试了一下官方方案，不过发现自己并不喜欢这个方案，最重要的原因是 —— 需要多安装一个 Ruby！我对此事是拒绝的，因为我并不想安装一些平常用不到的东西（别误会，我对 Ruby 本身并没有偏见）。 之后我发现了使用 Node.js 的 Hexo，这才是我想要的！ 开始动手好吧，这里没什么可写的，写得再多也没有 Hexo官网 权威、时效性强，需要建站的话，直接参考 Hexo官网 就好了。 这里只说几个新手可能遇到的问题，老司机们请抄近道。 npm 的配置虽然有了更为先进的 yarn，我还是固守在 npm 的身边，毕竟用习惯了。这里使用 npm 可能出现的问题是超时。原因嘛，npm 服务器在国外，经常被墙。国内的用户们想要使用 npm 的话，可以选择 淘宝镜像。当然，它会很热情地推荐你使用 cnpm 来代替 npm，不要理它。关于如何配置淘宝镜像，网上很容易搜到，其实一行命令就好： 1234# 配置 registrynpm config set registry https://r.cnpmjs.org/# 验证配置是否修改成功npm config get registry theme 的切换安装之后，默认的 landscape 主题我是拒绝的，选择一个能够长时间忍受的主题还是很有必要的。我在 官网 上找到了一个 Material Design 的 indigo 主题。没错，就是你现在看到的这个！安装 indigo 主题，请戳 作者的github，按照大佬的指导一步步来就行了。 调教博客修改侧边栏为中文进入 indigo 的配置文件（_config.yml），仿照【menu-home】，在【menu-archives】等下面几个 menu 的配置里，分别加上 text 属性作为显示的名称： /themes/indigo/_config.yml1234567menu: home: text: 主页 url: / archives: text: 归档 url: /archives 然后可以修改后面的【tags_title】【archives_title】【categories_title】属性，作为从 menu 进入相应页面后的标题： /themes/indigo/_config.yml1234# 页面标题tags_title: 标签archives_title: 归档categories_title: 分类 tags &amp; categories下面将以 tags 为例进行说明，categories 同理设置即可。 首先需要开启 hexo 的 tags 功能： 1hexo new page tags 此时会生成一个新的文件 source/tags/index.md，修改其内容： 1234567---title: tagsdate: 2017-10-04 19:50:45type: \"tags\"layout: \"tags\"comment: false--- 修改 scaffolds/draft.md： 1234---title: &#123;&#123; title &#125;&#125;tags: &#123;&#123; tags &#125;&#125;--- 修改 scaffolds/post.md： 12345---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: &#123;&#123; tags &#125;&#125;--- 检查 indigo 主题下的 menu-tags 是否打开： /themes/indigo/_config.yml12menu: tags: /tags 最后是自己的文章里要有相应的 tags 来区分，比如： 12345---title: 使用hexo搭建github博客date: 2017-10-05 10:01:55tags: [随笔, 博客]--- 注意冒号之后的空格，以及“,”要用半角不要用全角，否则程序会不认。 返回顶部hexo 竟然没有自带返回顶部的按钮，好奇怪。不过自己做一个也费不了什么功夫。我打算自己做一个，稍后发上来。 代码自动换行有空再做 插入图片设置图片路径有两种，一种是绝对路径，可以将图片单独存放在source/images路径下，通过类似 1![](/images/image1.jpg) 这种方式来插入图片。 另一种是相对路径，图片可以和博文放在同目录下，这种方法需要调整一下配置文件： _config.yml1post_asset_folder: true 以后再执行命令$ hexo new 时，hexo就会在生成文章post_name.md的同时，生成同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了，类似于这种用法： 1![](image1.jpg) 插入公式支持Hexo 博客中插入公式方案，我选的是 MathJax ，参见 Hexo博客插入数学公式 部署踩过的一个坑: 1234fatal: Could not read from remote repository.无法读取远程存储库。请确保你有正确的访问权限和存储库的存在。 出现这种错误，有可能在配置 _config.yml 的时候，deploy 没有写全，或者 repo 的写法不对，参考如下格式： /_config.yml1234deploy: type: git repo: http://github.com/username/username.github.io.git branch: master 这里，我们可以把生成、部署的命令，写成一个脚本，这样就不用去刻意记命令了： /upload.sh1234#!/bin/bash# hexo clean # 清理hexo generate # 生成hexo deploy # 部署 TODO评论系统；分享功能；目录折叠；代码高亮调整（比如bash）、行号隐藏显示可调； 干货所以这篇博客到底说了什么呢？ 什么也没说，只是把 Hexo建站方案 和 indigo主题 两个网址甩给了你，不会就找官方嘛！ 嗯，其实我就是来测试自己搭的博客是不是能用的 O(∩_∩)O 友善度由于这篇博文是在博客搭建得差不多才开始写的，所以记录的内容可能有所疏漏，欢迎评论补充 ～ 完","categories":[{"name":"随笔","slug":"other","permalink":"http://blogless.github.io/categories/other/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://blogless.github.io/tags/博客/"},{"name":"随笔","slug":"随笔","permalink":"http://blogless.github.io/tags/随笔/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-04T04:00:00.000Z","updated":"2019-08-25T03:09:15.676Z","comments":true,"path":"2017/10/04/hello-world/","link":"","permalink":"http://blogless.github.io/2017/10/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}