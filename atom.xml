<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客寥寥</title>
  
  <subtitle>从记笔记转向写博客，就像从写私有项目转向写开源项目一样困难</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blogless.github.io/"/>
  <updated>2019-09-05T13:20:52.477Z</updated>
  <id>http://blogless.github.io/</id>
  
  <author>
    <name>赵恒昶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MPI入门</title>
    <link href="http://blogless.github.io/2019/08/25/MPI%E5%85%A5%E9%97%A8/"/>
    <id>http://blogless.github.io/2019/08/25/MPI入门/</id>
    <published>2019-08-25T12:44:10.000Z</published>
    <updated>2019-09-05T13:20:52.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MPI安装入门"><a href="#MPI安装入门" class="headerlink" title="MPI安装入门"></a>MPI安装入门</h2><p>参考 <a href="https://gist.github.com/pajayrao/166bbeaf029012701f790b6943b31bb2" target="_blank" rel="noopener">https://gist.github.com/pajayrao/166bbeaf029012701f790b6943b31bb2</a></p><p>OS: Ubuntu 18.04 LTS</p><h3 id="安装MPI"><a href="#安装MPI" class="headerlink" title="安装MPI"></a>安装MPI</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y mpich</span><br></pre></td></tr></table></figure><h3 id="使用MPI"><a href="#使用MPI" class="headerlink" title="使用MPI"></a>使用MPI</h3><h4 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h4><p>基本函数列表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MPI_Init</span><br><span class="line">MPI_Finalize</span><br><span class="line">MPI_Comm_rank</span><br><span class="line">MPI_Comm_size</span><br></pre></td></tr></table></figure><p>其中，<code>MPI_Init</code>用于初始化MPI程序，<code>MPI_Finalize</code>用于结束MPI程序，二者应该成对使用（且只用一次），分别放在程序的开始和结束。<code>MPI_Comm_rank</code>和<code>MPI_Comm_rank</code>分别用于获取进程总数和当前进程的序号，一般以 rank 为 0 的进程作为主进程。基本使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> rank, size;</span><br><span class="line">  MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">  MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line">  MPI_Comm_size(MPI_COMM_WORLD, &amp;size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rank == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something else...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MPI_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="点对点通信函数"><a href="#点对点通信函数" class="headerlink" title="点对点通信函数"></a>点对点通信函数</h4><p>点对点的通信原语是 <code>send</code> 和 <code>recv</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MPI_Send</span><br><span class="line">MPI_Recv</span><br></pre></td></tr></table></figure><h4 id="群组通信函数"><a href="#群组通信函数" class="headerlink" title="群组通信函数"></a>群组通信函数</h4><p>广播函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MPI_Bcast</span><br></pre></td></tr></table></figure><p>群发群收函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MPI_Scatter</span><br><span class="line">MPI_Gather</span><br><span class="line">MPI_Allgather</span><br></pre></td></tr></table></figure><p>Reduce函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MPI_Reduce</span><br><span class="line">MPI_Alreduce</span><br></pre></td></tr></table></figure><p>以上几组函数的区别是：Bcast会将一份数据完整复制给所有进程，而Scatter把这份数据拆开分给每个进程一部分；Gather从所有进程中收集数据，汇总到一个进程中，而Reduce拿到的是所有进程中数据操作后的结果；Gather和Reduce汇总数据到一个进程，AllXxx是把汇总后的结果分发给每一个进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MPI安装入门&quot;&gt;&lt;a href=&quot;#MPI安装入门&quot; class=&quot;headerlink&quot; title=&quot;MPI安装入门&quot;&gt;&lt;/a&gt;MPI安装入门&lt;/h2&gt;&lt;p&gt;参考 &lt;a href=&quot;https://gist.github.com/pajayrao/166bb
      
    
    </summary>
    
      <category term="编程" scheme="http://blogless.github.io/categories/programming/"/>
    
    
      <category term="C/C++" scheme="http://blogless.github.io/tags/C-C/"/>
    
      <category term="编程" scheme="http://blogless.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="并行" scheme="http://blogless.github.io/tags/%E5%B9%B6%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>我差一点就转投hugo了</title>
    <link href="http://blogless.github.io/2019/08/15/%E6%88%91%E5%B7%AE%E4%B8%80%E7%82%B9%E5%B0%B1%E8%BD%AC%E6%8A%95hugo%E4%BA%86/"/>
    <id>http://blogless.github.io/2019/08/15/我差一点就转投hugo了/</id>
    <published>2019-08-15T12:57:04.000Z</published>
    <updated>2019-09-06T01:58:01.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="博客系统迁移：从hexo到hugo"><a href="#博客系统迁移：从hexo到hugo" class="headerlink" title="博客系统迁移：从hexo到hugo"></a>博客系统迁移：从hexo到hugo</h2><p>电脑重装系统，想起来自己的博客，重装node和hexo之后发现原来的博客无法生成了，看起来是某些依赖版本对不上了，真是令人头大，重新搜索了一下 <code>Static Site Generator</code>，发现了 hugo 这个好东西，决定尝试一下。<br>相比hexo，hugo提供二进制安装，没有依赖，而且速度非常快，令人心旷神怡。如果说有什么缺点的话，那就是hugo主题明显没有hexo精良。</p><h2 id="安装hugo"><a href="#安装hugo" class="headerlink" title="安装hugo"></a>安装hugo</h2><p>hugo是用go语言开发的，由大名鼎鼎的<a href="https://github.com/spf13" target="_blank" rel="noopener">spf13</a>发起，安装也很简单，可以<a href="https://gohugo.io/getting-started/installing/#source" target="_blank" rel="noopener">源码安装</a>，可以<a href="https://gohugo.io/getting-started/installing/#debian-and-ubuntu" target="_blank" rel="noopener">apt安装</a>，也可以<a href="https://gohugo.io/getting-started/installing/#snap-package" target="_blank" rel="noopener">snap安装</a>。这里我使用snap安装最新版hugo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ snap install hugo --channel=extended</span><br></pre></td></tr></table></figure><p>验证安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hugo version</span><br></pre></td></tr></table></figure><p>使用snap安装而不是apt的原因是，snap安装的版本比apt新，可以分别通过<code>snap info hugo</code>和<code>apt show hugo</code>查看二者提供的版本信息。</p><h2 id="创建博客仓库"><a href="#创建博客仓库" class="headerlink" title="创建博客仓库"></a>创建博客仓库</h2><p>创建生成博客仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hugo new site blog</span><br></pre></td></tr></table></figure><p>使用 git 管理项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>在 github 上创建一个同名空仓库，之后把本地仓库和远程仓库联系起来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先是本地仓库联系远程仓库</span></span><br><span class="line">$ git remote add origin git@github.com:&lt;your-name&gt;/blog.git</span><br><span class="line"><span class="comment"># 其次是本地分支联系远程分支，记不住没关系，直接`git pull`会提醒你如何设置的</span></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream-to=origin/master master</span><br></pre></td></tr></table></figure><p>最后，把本地仓库同步到远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 然后更新本地的origin</span></span><br><span class="line">$ git fetch</span><br><span class="line"><span class="comment"># 本地同步远程，要求远程仓库为空是为了避免冲突</span></span><br><span class="line">$ git rebase -i origin/master</span><br></pre></td></tr></table></figure><p>如果有多个git用户，从而不想设置全局git用户，而是每个仓库单独设置的话，你可能需要在<code>git init</code>之后先输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name <span class="string">"&lt;your-name&gt;"</span></span><br><span class="line">$ git config user.email <span class="string">"&lt;your-email&gt;"</span></span><br></pre></td></tr></table></figure><p>其实就是省略了 <code>--global</code> 参数</p><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>之前的Hexo博客使用的是indigo主题，这里我想保持迁移前后博客风格一致，以后有需要再修改博客主题，所幸我在<a href="https://github.com/gohugoio/hugoThemes" target="_blank" rel="noopener">hugo themes</a> 找到了最为接近的<a href="https://github.com/pdevty/polymer" target="_blank" rel="noopener">polymer</a>，安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span>  https://github.com/pdevty/polymer.git themes/polymer</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule add https://github.com/pdevty/polymer.git themes/polymer</span><br></pre></td></tr></table></figure><p>阅读polymer源码可以发现，左侧栏需要的图标来自 <a href="https://github.com/PolymerElements/iron-icons/blob/master/iron-icons.js" target="_blank" rel="noopener">PolymerElements</a>，后面添加的<code>about</code>和<code>archives</code>都需要从这里选取图标。</p><h2 id="加入-mathjax-公式支持"><a href="#加入-mathjax-公式支持" class="headerlink" title="加入 mathjax 公式支持"></a>加入 mathjax 公式支持</h2><p>为保证所有文件都加入Latex公式支持，最好的办法是用一个模板把这个js库引入footer，比如写入到 layouts/partials/footer.html，具体来讲就是把 当前theme下的footer.html 复制到根目录下的layout里，然后添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参考 <a href="https://www.gohugo.org/doc/tutorials/mathjax/" target="_blank" rel="noopener">https://www.gohugo.org/doc/tutorials/mathjax/</a><br>Mathjax参数<code>?config=TeX-AMS-MML_HTMLorMML</code>是告诉MathJax，我们要用到的叫TeX-AMS-MML_HTMLorMML.js的配置文件，其用来控制显示数学公式的HTMl显示输出</p><!-- 可以在文章那个开头加入 `markup: mmark` 来切换引擎，hugo默认提供Blackfriday和mmark，默认使用 Blackfriday 来调用mathjax --><p>提速，一是切换到国内的cdn，这里使用的是 <a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">BootCDN</a>,Bootstrap中文网提供的CDN服务，选择它的原因是新浪快但是没有资源，百度阿里网站找不到，头条资源很丰富但官网卡死……<br>    <script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></p><p>二是<br>按需加载，只有在文章开头加上<code>math: true</code>时才加载mathjax：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;if .Params.math &#125;&#125;</span><br><span class="line">    <span class="comment">&lt;!-- &lt;script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="解决-markdown-与-mathjax-冲突问题"><a href="#解决-markdown-与-mathjax-冲突问题" class="headerlink" title="解决 markdown 与 mathjax 冲突问题"></a>解决 markdown 与 mathjax 冲突问题</h2><p>具体来讲就是 latex的换行语法 <code>\\</code> 在markdown会被理解为转义，下标<code>_</code>会被markdown当作强调。<br>修改公式让mathjax适应markdown是不可能的，必须让markdown向mathjax低头，也就是想办法不让markdown解析公式。以后宗办法是使用markdown的代码块（反引号），但是这样有个问题就是代码块有自己的样式，会比较混乱。更好的解决办法是引入html标签，把公式用 <code>&lt;div&gt;&lt;/div&gt;</code> 或者 <code>&lt;p&gt;&lt;/p&gt;</code> 包起来，这样markdown就不会去解析这里面的内容了。</p><h2 id="favicon"><a href="#favicon" class="headerlink" title="favicon"></a>favicon</h2><p>浏览器检测发现有一个资源404，原因是拿不到favicon.ico，也就是浏览器标签栏上 title 左侧的那个小图片，这里我们要做的是自己制作一个favicon。首先我找到了一个制作favicon的网站<code>https://tool.lu/favicon/</code>，然后把博客头像上传，制作后下载到本地static根目录下（注意不能是static/img下），再次刷新网页，favicon已经有了。</p><p>##</p><p>创建一个 about 页面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hugo new about.md</span><br></pre></td></tr></table></figure><p>创建第一篇文章，放到 post 目录，方便之后生成聚合页面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hugo new post/first.md</span><br></pre></td></tr></table></figure><p>永久连接 用 title 比用 filename 好</p><h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><ol><li>hexo中markdown博文中metadata中的categories可以不用加<code>[]</code>，但是hugo严格要求加上，与tags保持一致。</li><li>左侧几项都应该是single.html (?) 原来hexo里面的categories应该删掉，不然会阻止正常目录功能（或者应该正确组织来定制自己的目录格式？？）同时，tags也可以删掉，about可以拿出来而不用放入单独的文件夹。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 待Archive功能完成后加入到 layouts/partials/header.html --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;&#123;$baseurl&#125;&#125;/archives/</span>&gt;</span><span class="tag">&lt;<span class="name">paper-item</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">iron-icon</span> <span class="attr">icon</span>=<span class="string">"archive"</span>&gt;</span><span class="tag">&lt;/<span class="name">iron-icon</span>&gt;</span>　<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex"</span>&gt;</span>Archives<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">iron-icon</span> <span class="attr">icon</span>=<span class="string">"chevron-right"</span>&gt;</span><span class="tag">&lt;/<span class="name">iron-icon</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">paper-item</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>把博文文件夹从 _posts 改名为 post 以使用永久连接匹配的post</li><li>_drafts 文件夹不能表示文件是草稿了，要在每个草稿文件头部 加入 <code>draft:true</code> 才行了。</li><li>图片不能放在博文目录下了，要放到static/img下去</li></ol><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li>添加 archive、about</li><li>添加 copyright &amp; license</li><li>添加 subtitle</li><li>添加 description</li><li>添加 highlight</li><li>添加 评论系统</li><li>添加 TOC (table of content)</li><li>添加 回到顶部</li><li>上一篇/下一篇 图标处 添加文章名称</li><li>about 单页去除 上一篇/下一篇</li></ul><p>123hurray 最先fork，有个bugfix，6提交<br>stephen-marshall-moore 44提交，质量很高<br>tonychee7000  111提交，都是灌水</p><h2 id="更好的主题选择"><a href="#更好的主题选择" class="headerlink" title="更好的主题选择"></a>更好的主题选择</h2><p>功能全，持续更新，编译后网页速度快</p><p><a href="https://github.com/rujews/maupassant-hugo" target="_blank" rel="noopener">飞雪无情的theme</a>，比较不符合我的审美，但是功能齐全，持续更新</p><p>但是这个功能也不全：</p><ul><li>Toc 需要在每篇文章手动开启</li><li>只有see also， 没有上一篇/下一篇</li><li>据说 see also 只显示发表时间早于当前文章的？</li><li>没有站内搜索（只能借助于google站内搜索之内的办法）</li></ul><p>这个主题可以使用基于github issue的 <a href="https://utteranc.es/" target="_blank" rel="noopener">utterances</a> 使用起来非常简单，参考<br><a href="https://www.cnblogs.com/stevexu/p/10808134.html" target="_blank" rel="noopener">博客使用 utterances 作为评论系统</a></p><h2 id="打退堂鼓了"><a href="#打退堂鼓了" class="headerlink" title="打退堂鼓了"></a>打退堂鼓了</h2><p>尝试完之后，我又暂时退回了hexo阵营，为什么呢？最关键的原因在于，就连maupassant-hugo这个目前最佳的主题都没有提供站内搜索啊！！！相比之下hexo的基于jsonContent这种站内搜索才是我的最爱。<br>所以，我又缩回去了，重新安装了hexo+indigo最新版，并不费时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;博客系统迁移：从hexo到hugo&quot;&gt;&lt;a href=&quot;#博客系统迁移：从hexo到hugo&quot; class=&quot;headerlink&quot; title=&quot;博客系统迁移：从hexo到hugo&quot;&gt;&lt;/a&gt;博客系统迁移：从hexo到hugo&lt;/h2&gt;&lt;p&gt;电脑重装系统，想起来
      
    
    </summary>
    
      <category term="随笔" scheme="http://blogless.github.io/categories/other/"/>
    
    
      <category term="博客" scheme="http://blogless.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="随笔" scheme="http://blogless.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>你应该避免的C++糟粕</title>
    <link href="http://blogless.github.io/2017/10/26/%E4%BD%A0%E5%BA%94%E8%AF%A5%E9%81%BF%E5%85%8D%E7%9A%84C-%E7%B3%9F%E7%B2%95/"/>
    <id>http://blogless.github.io/2017/10/26/你应该避免的C-糟粕/</id>
    <published>2017-10-26T10:29:51.000Z</published>
    <updated>2019-09-06T01:38:07.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>很多公司招人的时候，都会招聘 <code>C/C++程序员</code>，然而世界上并不存在 C/C++ 这门语言。即使在早期设计的时候，C++ 是完全兼容 C 的，但是经过这么多年的发展，C++ 已经发展成了和 C 有着明显区别的一种语言，甚至于兼容 C 的部分早就成为了 C++ 发展的桎梏，成为了 C++ 最令人诟病的部分。</p><p>当然，C 语言是一门优秀的语言，其简洁高效的特性是其他语言难以比肩的。但是在 C++ 程序里面，我们更好的做法是写 C++ 程序，或者更明确一些 —— <code>Modern C++</code>，而非 <code>C with classes</code>，尽量避免让 C++ 程序出现 <code>Bad Smell</code>。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>以下几点是值得注意的：</p><h3 id="多维数组传参"><a href="#多维数组传参" class="headerlink" title="多维数组传参"></a>多维数组传参</h3><p>以二维数组为例，典型的 C 语言传参方式是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>** a, <span class="keyword">size_t</span> sz)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* arr[SIZE_ARR];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;SIZE_ARR; ++i)</span><br><span class="line">    arr[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><p>这是什么意思呢？这里表示的是我们传入的其实还是一个一维数组，只是这个数组的元素恰好都是指向另一组等长的一维数组的指针。</p><p>要理解为什么参数只能传递一维数组，而不能传递高维数组，其实很简单。我们注意到函数在传入数组作为参数的时候，还需要多传一个参数说明数组长度（这在 Java/JavaScript/Python 等语言之中都是不必要的）。在获取二维数组 a[m][n] 中的元素 a[i][j] 的时候，我们需要做的就是计算 *(a+i×n+j)，也就是我们必须要知道 n 才能计算出元素地址。所以如果我们想要把二维数组作为参数传入函数的时候，只能是 <code>fun(int a[][n], size_t n);</code> 这种形式，但是这里的 n 显然不是我们想要展示出来的。</p><p>那么 C++ 的写法是什么呢？当然是 STL 容器了！这里根据数组长度是否可变（C99支持VLA）使用两种不同的容器来完成 —— <code>std::array</code> 和 <code>std::vector</code>。以 vector 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funv</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it1, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = it1; it != it2; ++it)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> jt = it-&gt;begin(); jt != it-&gt;end(); ++jt)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *jt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//array&lt;array&lt;int, 5&gt;, 4&gt; a;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">    funv(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>上面已经展示过了，C 语言中的定长数组使用 <code>std::array</code> 代替，变长数组使用 <code>std::vector</code> 代替。下标遍历使用迭代器代替。</p><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3><p>C++ 原则之 RAII（资源获取即初始化），如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="keyword">int</span> a[SIZE_A];</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, SIZE_A&gt; a;  <span class="comment">//array&lt;int, SIZE_A&gt; a = &#123;&#125;;</span></span><br><span class="line">a.fill(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(SIZE_A, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>多维数组初始化依然使用循环赋值这一通用做法。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>C++ 避免使用裸指针。用 auto_ptr（已废弃）、unique_ptr、shared_ptr、weak_ptr 代替。具体用法以后有机会再写。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>C 语言没有字符串，只有字符数组这一原始结构。C++ 前进了一步，std::string 对 char[] 进行了封装。（当然，仍然是糟糕的设计，只比 char[] 稍好一点，优良的设计可以参考 JavaScript 等语言的字符串设计）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> m;<span class="comment">//to_string(n);</span></span><br><span class="line">    <span class="keyword">int</span> n;   <span class="comment">//itoa(n);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">' '</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; atol(m.c_str()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; strtol(m.c_str(), <span class="literal">nullptr</span>, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stol(m, <span class="literal">nullptr</span>, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">string</span>::size_type idx;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stol(m, &amp;idx, n) &lt;&lt; <span class="string">' '</span> &lt;&lt; idx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>万幸，一直弄不明白的函数指针问题终于有了解决方案</p><h3 id="new-delete"><a href="#new-delete" class="headerlink" title="new/delete"></a>new/delete</h3><p>RAII，资源获取即初始化，你值得拥有。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">3</span>);   <span class="comment">// 栈空间</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *b = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>);  <span class="comment">//堆空间</span></span><br></pre></td></tr></table></figure><p>关于选用栈空间还是堆空间的问题，还会有一篇文章来说明这个问题。</p><h3 id="（宏替换、函数展开）"><a href="#（宏替换、函数展开）" class="headerlink" title="（宏替换、函数展开）"></a>（宏替换、函数展开）</h3><h3 id="危险函数-gets、fgets、"><a href="#危险函数-gets、fgets、" class="headerlink" title="危险函数 gets、fgets、"></a>危险函数 gets、fgets、</h3><h2 id="友善度"><a href="#友善度" class="headerlink" title="友善度"></a>友善度</h2><p>随着 C++ 标准的更新继续完善。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.cnblogs.com/egametang/archive/2012/04/16/2452020.html" target="_blank" rel="noopener">C++不是C/C++ - 唐诗 - 博客园</a></li></ul><p><a href="https://bbs.avplayer.org/t/c-1-c/264" target="_blank" rel="noopener">https://bbs.avplayer.org/t/c-1-c/264</a></p><p><a href="http://www.aizhuanji.com/a/0VoMRExe.html" target="_blank" rel="noopener">http://www.aizhuanji.com/a/0VoMRExe.html</a></p><p><a href="http://www.cnblogs.com/Solstice/archive/2011/07/17/2108715.html" target="_blank" rel="noopener">http://www.cnblogs.com/Solstice/archive/2011/07/17/2108715.html</a></p><p><a href="http://blog.csdn.net/sd6733531/article/details/7400202" target="_blank" rel="noopener">http://blog.csdn.net/sd6733531/article/details/7400202</a></p><h2 id="姊妹篇"><a href="#姊妹篇" class="headerlink" title="姊妹篇"></a>姊妹篇</h2><p><a href="/2017/10/27/Modern-C">Modern C++</a></p><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;很多公司招人的时候，都会招聘 &lt;code&gt;C/C++程序员&lt;/code&gt;，然而世界上并不存在 C/C++ 这门语言。即使在早期设计的时候，C
      
    
    </summary>
    
    
      <category term="C/C++" scheme="http://blogless.github.io/tags/C-C/"/>
    
      <category term="编程" scheme="http://blogless.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>奇技淫巧之尾递归</title>
    <link href="http://blogless.github.io/2017/10/25/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E4%B9%8B%E5%B0%BE%E9%80%92%E5%BD%92/"/>
    <id>http://blogless.github.io/2017/10/25/奇技淫巧之尾递归/</id>
    <published>2017-10-25T11:50:26.000Z</published>
    <updated>2019-08-25T03:09:15.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>这几天偶然看到关于尾递归的文章，联想到之前写过的斐波那契数列，干脆就单开一篇专门写一下尾递归的事，留待以后查阅。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="什么是尾递归"><a href="#什么是尾递归" class="headerlink" title="什么是尾递归"></a>什么是尾递归</h3><p>尾递归是一种<strong>尾调用</strong>。所谓尾调用，望文生义就是指函数的最后一步也是一个函数调用。那么尾递归也就是函数尾调用自身。</p><h3 id="为什么要用尾递归"><a href="#为什么要用尾递归" class="headerlink" title="为什么要用尾递归"></a>为什么要用尾递归</h3><p>与一般递归相比，尾递归的效率更高，其主要原因在于：</p><p>一般递归调用时需要重新开辟函数调用栈；</p><p>尾递归调用时编译器可以自动优化，直接利用原有的栈进行调用。</p><p>虽然栈的运行效率相比堆效率高很多，但减小栈的开销仍然是有意义的，尤其是在栈的开销很大的时候。</p><h3 id="尾递归的效率提升"><a href="#尾递归的效率提升" class="headerlink" title="尾递归的效率提升"></a>尾递归的效率提升</h3><p>我们可以拿之前写过的斐波那契数列做实验对比一下：</p><figure class="highlight c++"><figcaption><span>一般递归</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>尾递归</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Fibonacci_tail：斐波那契数列尾递归形式</span></span><br><span class="line"><span class="comment"> * n：待求值</span></span><br><span class="line"><span class="comment"> * acc1：累计值1</span></span><br><span class="line"><span class="comment"> * acc2：累计值2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fibonacci_tail</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> acc1, <span class="keyword">long</span> acc2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> acc2; <span class="comment">//acc2</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Fibonacci_tail(n - <span class="number">1</span>, acc2, acc1 + acc2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>效率对比</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> t1 = clock();</span><br><span class="line">    Fibonacci(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">clock_t</span> t2 = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t2 - t1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">clock_t</span> t3 = clock();</span><br><span class="line">    Fibonacci_tail(<span class="number">20</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">clock_t</span> t4 = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t4 - t3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>运行结果</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">278</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>可以看到，尾递归优化过的斐波那契数列，运行效率有质的提高。不仅仅是因为栈的利用率提高，而且栈的调用层次从原来的树形结构编程了朴素的线性结构，节约了大量的重复计算。如果从尾递归再进一步优化的话，马上就是迭代形式。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>尾递归虽然效率比一般递归效率有提高，但是理解起来的难度也更高，因此建议在彻底弄懂之后再写尾递归代码，并且加上必要的注释。或者，直接写成迭代形式，更好理解，并且效率更高。</p><p>先能够写正确的代码，再写高效的代码。</p><p>当然，不只是 C++ 会有尾递归优化。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">尾递归优化 - 阮一峰的网络日志</a></li></ul><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;这几天偶然看到关于尾递归的文章，联想到之前写过的斐波那契数列，干脆就单开一篇专门写一下尾递归的事，留待以后查阅。&lt;/p&gt;
&lt;h2 id=&quot;正
      
    
    </summary>
    
    
      <category term="算法" scheme="http://blogless.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="奇技淫巧" scheme="http://blogless.github.io/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>C++中的骚操作</title>
    <link href="http://blogless.github.io/2017/10/25/C-%E4%B8%AD%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C/"/>
    <id>http://blogless.github.io/2017/10/25/C-中的骚操作/</id>
    <published>2017-10-25T10:07:30.000Z</published>
    <updated>2019-09-05T11:37:58.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>这篇文章的起因是我在写程序的时候，发现总是用到这样的简单循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Do something to a[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，有时候它也可能是这种形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x: a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Do something to x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种循环操作中，后一次的操作与前一次的操作有时候没有必然联系，这样写也仅仅只是因为他们在同一个数组中。</p><p>然而引入临时变量总是让人不爽，我总是情不自禁回想起 python 和 JavaScript 中的 map / reduce 操作。</p><p>那么，C++ 里面有这种 map / reduce 函数吗？</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>现代语言总是会有一些高级操作，能够极大地提高我们编写程序的效率和准确度。用惯了 map / reduce，再回来使用循环总是会让人有些不爽。所幸，我们需要的功能 STL 中已经存在了，只是平常我们没有注意到。现在我就要把它发掘出来，让他重见天日。</p><h3 id="transform-lt-map"><a href="#transform-lt-map" class="headerlink" title="transform &lt;- map"></a>transform &lt;- map</h3><p>transform 有两种形式：</p><figure class="highlight c++"><figcaption><span><algorithm>transform</algorithm></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unary operation(1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">UnaryOperation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">transform</span> (<span class="title">InputIterator</span> <span class="title">first1</span>, <span class="title">InputIterator</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">UnaryOperation</span> <span class="title">op</span>);</span></span><br><span class="line"><span class="comment">//binary operation(2)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">transform</span> (<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">OutputIterator</span> <span class="title">result</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">BinaryOperation</span> <span class="title">binary_op</span>);</span></span><br></pre></td></tr></table></figure><p>首先看一下 transform 是怎么实现的：</p><figure class="highlight c++"><figcaption><span><algorithm>transform</algorithm></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (first1 != last1)</span><br><span class="line">    &#123;</span><br><span class="line">        *result = op(*first1); </span><br><span class="line"><span class="comment">// or: *result = binary_op(*first1, *first2++);</span></span><br><span class="line">        ++result;</span><br><span class="line">        ++first1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单直接，基本就是把我们手写 map 的过程抽象一下提取出模板。那我们直接上使用的例子就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_increase</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> ++i; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::transform (foo.begin(), foo.end(), bar.begin(), op_increase);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// std::plus adds together its two arguments:</span></span><br><span class="line"><span class="built_in">std</span>::transform (foo.begin(), foo.end(), bar.begin(), foo.begin(), <span class="built_in">std</span>::plus&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure><p>一个经典的用法是对字符串实现大小写转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">transform(s.begin(), s.end(), s_lower.begin(), ::<span class="built_in">tolower</span>);</span><br><span class="line">transform(s.begin(), s.end(), s_upper.begin(), ::<span class="built_in">toupper</span>);</span><br><span class="line"><span class="comment">//tolower和toupper 分别在两个地方定义了：一个是 std::tolower ，一个是在 cctype中定义的。</span></span><br><span class="line"><span class="comment">//这里使用::是为了使用cctype里面的那个。</span></span><br><span class="line"><span class="comment">//记得给s_lower、s_upper事先 resize(s.size())</span></span><br></pre></td></tr></table></figure><h3 id="accumulate-lt-reduce"><a href="#accumulate-lt-reduce" class="headerlink" title="accumulate &lt;- reduce"></a>accumulate &lt;- reduce</h3><p>C++ 中的 <code>accumulate</code> 函数同样是两种形式：</p><figure class="highlight c++"><figcaption><span><numeric>accumulate</numeric></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sum(1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">init</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//custom(2)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">init</span>,</span></span><br><span class="line"><span class="class">                 <span class="title">BinaryOperation</span> <span class="title">binary_op</span>);</span></span><br></pre></td></tr></table></figure><p>其实现：</p><figure class="highlight c++"><figcaption><span><numeric>accumulate</numeric></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (first != last)</span><br><span class="line">    &#123;</span><br><span class="line">        init = init + *first;</span><br><span class="line"><span class="comment">// or: init = binary_op(init, *first);</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用样例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缺省求和</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::accumulate(nums.begin(), nums.end(), init);</span><br><span class="line"></span><br><span class="line"><span class="comment">//库函数求和</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::accumulate (numbers, numbers+<span class="number">3</span>, init, <span class="built_in">std</span>::plus&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义函数求和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_plus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::accumulate (numbers, numbers+<span class="number">3</span>, init, op_plus);</span><br></pre></td></tr></table></figure><p>当然，不仅仅是求和，通过修改传入的函数参数，还可以实现求积等功能。</p><h3 id="copy-if-lt-filter"><a href="#copy-if-lt-filter" class="headerlink" title="copy_if &lt;- filter"></a>copy_if &lt;- filter</h3><p><code>copy_if</code> 是 copy 系列函数中的一个，会对被 copy 的对象进行筛选以判断是否执行copy操作。其函数原型为：</p><figure class="highlight c++"><figcaption><span><algorithm>copy_if</algorithm></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">UnaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">copy_if</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">UnaryPredicate</span> <span class="title">pred</span>);</span></span><br></pre></td></tr></table></figure><p>内部实现参考：</p><figure class="highlight c++"><figcaption><span><algorithm>copy_if</algorithm></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (first != last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pred(*first))</span><br><span class="line">        &#123;</span><br><span class="line">            *result = *first;</span><br><span class="line">            ++result;</span><br><span class="line">        &#125;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用样例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy only positive numbers:</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">std</span>::copy_if (foo.begin(), foo.end(), bar.begin(), [](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> !(i&lt;<span class="number">0</span>);&#125; );</span><br><span class="line">bar.resize(<span class="built_in">std</span>::distance(bar.begin(),it));  <span class="comment">// shrink container to new size</span></span><br></pre></td></tr></table></figure><h2 id="关于-lambada-表达式"><a href="#关于-lambada-表达式" class="headerlink" title="关于 lambada 表达式"></a>关于 lambada 表达式</h2><p>在传入函数参数的时候，往往作为参数的函数我们只会在函数中使用这么一次，这个时候单独定义一个全局函数是很没有必要的。在 ES6 中我们使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>，python 有 <a href="https://docs.python.org/3/reference/expressions.html#lambda" target="_blank" rel="noopener">Lambda Expressions</a>，Java 8 也引入了 <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">Lambda Expressions</a> 。而 C++11 中也引入了这个现代化的特性 ——（虽然很丑但也算是） <a href="http://zh.cppreference.com/w/cpp/language/lambda" target="_blank" rel="noopener">Lambda 表达式 (C++11 起)</a></p><p>关于 C++ lambda 表达式，以后想起来的时候还会写文章总结。</p><h2 id="C-并行计算库"><a href="#C-并行计算库" class="headerlink" title="C++ 并行计算库"></a>C++ 并行计算库</h2><p>实际上，我们还可以使用专业的并行计算库，充分利用多核性能来提高运算效率，如 Intel 的 TBB （Intel® Threading Building Blocks） 或者 Microsoft 的 PPL （Parallel Patterns Library）。具体用法可以参考 <a href="http://www.cnblogs.com/qicosmos/p/3517166.html" target="_blank" rel="noopener">c++并行计算库TBB和PPL的基本用法 - qicosmos(江南) - 博客园</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="http://www.cplusplus.com/reference/algorithm/transform/?kw=transform" target="_blank" rel="noopener">transform - C++ Reference</a></p></li><li><p><a href="http://www.cplusplus.com/reference/numeric/accumulate/?kw=accumulate" target="_blank" rel="noopener">accumulate - C++ Reference</a></p></li><li><p><a href="http://www.cplusplus.com/reference/algorithm/copy_if/" target="_blank" rel="noopener">copy_if - C++ Reference</a></p></li></ul><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;这篇文章的起因是我在写程序的时候，发现总是用到这样的简单循环：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="C/C++" scheme="http://blogless.github.io/tags/C-C/"/>
    
      <category term="编程" scheme="http://blogless.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="http://blogless.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>或与加</title>
    <link href="http://blogless.github.io/2017/10/21/%E6%88%96%E4%B8%8E%E5%8A%A0/"/>
    <id>http://blogless.github.io/2017/10/21/或与加/</id>
    <published>2017-10-21T11:18:40.000Z</published>
    <updated>2019-09-06T01:32:50.122Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://www.nowcoder.com/questionTerminal/729f5e6e2acc4f3cb14a2262888f86fb" target="_blank" rel="noopener">牛客网</a> 上看到的一道题目，感觉有点意思，在这里做个记录。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定 x, k ，求满足 x + y = x | y 的第 k 小的正整数 y 。 | 是二进制的或(or)运算，例如 3 | 5 = 7。<br>比如当 x=5，k=1时返回 2，因为5+1=6 不等于 5|1=5，而 5+2=7 等于 5 | 2 = 7。</p><p>输入描述:</p><blockquote><p>每组测试用例仅包含一组数据，每组数据为两个正整数 x , k。 满足 0 &lt; x , k ≤ 2,000,000,000。</p></blockquote><p>输出描述:</p><blockquote><p>输出一个数y。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>第一反应是暴力，但是会超时，没关系，先看看在暴力的基础上能不能进行优化。</p><p>这里会用到一些数学知识，观察 <code>x + y = x | y</code> 之后我们可以得出以下结论：</p><ol><li>x + y 的长度只能是 x、y 之中的最大长度，因为 x | y 长度为 x、y 之中的最大长度；</li><li>在任意 bit 位上，x、y 不能同时取 1。</li></ol><p>第二个结论很有意思，也是这道题的关键。在这之前我们先看一道简单题：</p><p><a href="https://leetcode.com/problems/sum-of-two-integers/description/" target="_blank" rel="noopener">371. Sum of Two Integers</a></p><blockquote><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p></blockquote><p>其实就是自己设计一个加法器，这里直接给出一种答案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1 = a ^ b;</span><br><span class="line">    <span class="keyword">int</span> t2 = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (t2 == <span class="number">0</span>) ? t1 : add(t1, t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看程序，如果 x、y 在任意 bit 位不同时取 1 的时候，t2 是不是就已经是 0 了？</p><p>在这这种情况下，我们有</p><div>$$ add(a, b) == t1 == a ^ b == a | b $$</div><p>是不是很神奇？</p><p>可以自己简单证明一下，到底 <code>x + y = x | y</code> 是不是 <code>x、y 在任意 bit 位不同时取 1</code> 的充要条件。</p><p>有了以上结论之后，在给定 x 的情况下，求 y 能取到的值，有什么好办法了吗？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>由之前的思考，我们可以得出结论，只需要抽取 x 取值为 0 的位进行取值遍历就能取出所有满足条件的 y：</p><div>$$y(i)=    \begin{cases}    0 & \text{x(i) = 1} \\    0,1 & \text{x(i) = 0}    \end{cases}$$</div><p>这里要取的是 第 k 个满足条件的数，那么把 k 的二进制表示拆出来填充进所有 x(i)=0 的位，工作也就完成了。</p><p>贴一份讨论区里面别人注释过的代码（这里我对代码和注释进行了一些修改）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; k;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> bitNum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 目标是把 k 的各位依次填在 x 中是 0 的位上。</span></span><br><span class="line">    <span class="comment">// bitNum 用来移动到 x 中 0 的位置，然后把 k 的最低位放在 x 的 0 位上,</span></span><br><span class="line">    <span class="comment">// k 左移，将下一位变成最低位,bitNum 一直左移到 x 中的下一个为 0 的位上</span></span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x &amp; bitNum) == <span class="number">0</span>) <span class="comment">// x 中 bitNum 为 0 的位,用来填充k的位</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans |= (bitNum * (k &amp; <span class="number">1</span>)); <span class="comment">// 将 k 的最低位取出来,放到在 x 的 bitNum 位上</span></span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bitNum &lt;&lt;= <span class="number">1</span>; <span class="comment">// bitNum 左移直到 x 中的 0 位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>结合了数学的程序还是酸爽啊～</p><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 &lt;a href=&quot;https://www.nowcoder.com/questionTerminal/729f5e6e2acc4f3cb14a2262888f86fb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt; 上看到的一道题目，感觉
      
    
    </summary>
    
      <category term="编程" scheme="http://blogless.github.io/categories/programming/"/>
    
    
      <category term="编程" scheme="http://blogless.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数学" scheme="http://blogless.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>华为笔试题</title>
    <link href="http://blogless.github.io/2017/10/20/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>http://blogless.github.io/2017/10/20/华为笔试题/</id>
    <published>2017-10-20T13:40:45.000Z</published>
    <updated>2019-08-25T03:09:15.704Z</updated>
    
    <content type="html"><![CDATA[<p>华为笔试第三题，今天刚做过的，还热乎着呢。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目大概是说：</p><p>有一种类似于 Lisp 的语言，包含 add、sub、mul、div 四中操作（均为小写），形式为 <code>(add 2 3)</code> 这种。其中，sub、div 的操作数只能是两个，add、mul 的操作数可以是两个以上，操作数可以为另一个表达式，也就是可以嵌套。</p><p>题目保证输入都是合法的语句，要求程序计算出最终结果并输出，弱出现 除数为零的情况，则输出 “error”。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>前缀表达式转后缀表达式，然后求值即可。</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>我的答案是这个，仅供参考：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 华为校招笔试：2017-10-20</span></span><br><span class="line"><span class="comment">// blogless.github.io</span></span><br><span class="line"><span class="comment">// 赵恒昶</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br><span class="line">    <span class="keyword">enum</span> Opt</span><br><span class="line">    &#123;</span><br><span class="line">        add,</span><br><span class="line">        sub,</span><br><span class="line">        mul,</span><br><span class="line">        div</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Opt&gt; Opstk;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">    getline(<span class="built_in">cin</span>, s); <span class="comment">//  cin &gt;&gt; s;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "s[i]:" &lt;&lt; s[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">' '</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (s[i])</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            stk.push(<span class="string">"("</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            Opt op = Opstk.top();</span><br><span class="line">            Opstk.pop();</span><br><span class="line">            <span class="keyword">switch</span> (op)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> sub:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> a = atol(stk.top().c_str());</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">long</span> b = atol(stk.top().c_str());</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="built_in">string</span> ans = to_string(b - a);</span><br><span class="line">                <span class="keyword">if</span> (stk.top() == <span class="string">"("</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    stk.push(ans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> div:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> a = atol(stk.top().c_str());</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">long</span> b = atol(stk.top().c_str());</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">string</span> ans = to_string(b / a);</span><br><span class="line">                <span class="keyword">if</span> (stk.top() == <span class="string">"("</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    stk.push(ans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> add:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (stk.top() != <span class="string">"("</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans += atol(stk.top().c_str());</span><br><span class="line">                    stk.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stk.pop();</span><br><span class="line">                stk.push(to_string(ans));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> mul:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (stk.top() != <span class="string">"("</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans *= atol(stk.top().c_str());</span><br><span class="line">                    stk.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stk.pop();</span><br><span class="line">                stk.push(to_string(ans));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            i += <span class="number">2</span>; <span class="comment">//add</span></span><br><span class="line">            Opstk.push(add);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "add-s[i]: " &lt;&lt; s[i] &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            i += <span class="number">2</span>; <span class="comment">//sub</span></span><br><span class="line">            Opstk.push(sub);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            i += <span class="number">2</span>; <span class="comment">//mul</span></span><br><span class="line">            Opstk.push(mul);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            i += <span class="number">2</span>; <span class="comment">//div</span></span><br><span class="line">            Opstk.push(div);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> neg = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                neg = <span class="literal">true</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> t = s[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i]))</span><br><span class="line">                t = t * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (neg)</span><br><span class="line">                t = -t;</span><br><span class="line">            stk.push(to_string(t));</span><br><span class="line">            i--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "num:" &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stk.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;华为笔试第三题，今天刚做过的，还热乎着呢。&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目大概是说：&lt;/p&gt;
&lt;p&gt;有一种类似于 Lisp 的语言，包含 add、sub
      
    
    </summary>
    
      <category term="编程" scheme="http://blogless.github.io/categories/programming/"/>
    
    
      <category term="C/C++" scheme="http://blogless.github.io/tags/C-C/"/>
    
      <category term="编程" scheme="http://blogless.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客插入数学公式</title>
    <link href="http://blogless.github.io/2017/10/18/Hexo%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <id>http://blogless.github.io/2017/10/18/Hexo博客插入数学公式/</id>
    <published>2017-10-18T04:37:16.000Z</published>
    <updated>2019-09-06T01:24:58.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>之前写 <a href="/2017/10/17/华为面试记（三）">华为面试记（三）</a> 的时候，用到了矩阵和数列，因此需要在博客中插入公式。抽空研究了一下，发现 Hexo 可以很方便地使用 MathJax 来插入数学公式，这里简单记录一下使用方法。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文分两部分，一部分讲怎么使用 <a href="https://www.mathjax.org/" target="_blank" rel="noopener">MathJax</a> 作为 Hexo 博客的公式编辑器，另一部分讲 LaTex 公式语法。</p><h3 id="MathJax-的使用"><a href="#MathJax-的使用" class="headerlink" title="MathJax 的使用"></a>MathJax 的使用</h3><h4 id="方法一：博文中启用-MathJax"><a href="#方法一：博文中启用-MathJax" class="headerlink" title="方法一：博文中启用 MathJax"></a>方法一：博文中启用 MathJax</h4><p>紧跟文档头部元数据之后，嵌入 html 语句：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">async</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>优点是按需插入，不需要插入公式的文档就不进行 MathJax 渲染，提高网页速度。</p><p>缺点是博文中插入了内容无关信息。</p><h4 id="方法二：用-config-yml-配置"><a href="#方法二：用-config-yml-配置" class="headerlink" title="方法二：用 _config.yml 配置"></a>方法二：用 _config.yml 配置</h4><p>修改主题目录下的 <code>_config.yml</code> 文件，改动如下：</p><figure class="highlight yml"><figcaption><span>/themes/indigo/_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  cdn:</span> <span class="string">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure><p>优点是不用在博文中加入过多无关信息。</p><p>缺点是可能每个页面都渲染，影响访问速度。</p><p>这里我使用的是第二种方案。</p><p>总之，现在 MathJax 编辑器就能使用了。</p><p>插入公式的时候，如果是插入行内，需要使用　<code>\(公式\)</code> 或者 <code>$公式$</code>　这种形式；如果是插入单行公式，则需要使用　<code>\[公式\]</code> 或者 <code>$$公式$$</code>　这种形式。（在输入这个<code>$</code>符号的时候，为了不被　MathJax 识别为公式进行渲染，我用 <strong>`</strong> 把它引用了起来。）</p><p>当然，使用 MathJax 插入公式也可以先在 <a href="https://www.mathjax.org/" target="_blank" rel="noopener">MathJax官网</a> 上输入公式预览效果，然后插入文档使用，它可以帮你检查语法错误。</p><h3 id="LaTex-语法"><a href="#LaTex-语法" class="headerlink" title="LaTex 语法"></a>LaTex 语法</h3><h4 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h4><p>双\公式内换行，cases实现大括号右多行赋值，&amp;用来对齐</p><p><em>但是这里公式换行需要三个<code>｜</code>，原因后面会解释</em></p><figure class="highlight markdown"><figcaption><span>斐波那契数列</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">F(n)=</span><br><span class="line"><span class="code">    \begin&#123;cases&#125;</span></span><br><span class="line"><span class="code">    1 &amp; \text&#123;n = 1&#125; \\</span></span><br><span class="line"><span class="code">    1 &amp; \text&#123;n = 2&#125; \\</span></span><br><span class="line"><span class="code">    F(n-1)+F(n-2) &amp; \text&#123;n&gt;2&#125;</span></span><br><span class="line"><span class="code">    \end&#123;cases&#125;</span></span><br><span class="line">$$</span><br></pre></td></tr></table></figure><div>$$F(n)=    \begin{cases}    1 & \text{n = 1} \\    1 & \text{n = 2} \\    F(n-1)+F(n-2) & \text{n>2}    \end{cases}$$</div><h4 id="角标"><a href="#角标" class="headerlink" title="角标"></a>角标</h4><p><code>^</code> 表示上标，<code>_</code>表示下标。如果上下标的内容多于一个字符，要用{}把这些内容括起来当成一个整体。上下标是可以嵌套的，也可以同时使用。</p><p>另外，如果要在左右两边都有上下标，可以用 <code>\sideset</code> 命令。</p><h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">  \begin&#123;pmatrix&#125; 1 &amp; 2 \\ 3 &amp; 4 \\ \end&#123;pmatrix&#125; </span><br><span class="line">  \begin&#123;bmatrix&#125; 1 &amp; 2 \\ 3 &amp; 4 \\ \end&#123;bmatrix&#125; </span><br><span class="line">  \begin&#123;vmatrix&#125; 1 &amp; 2 \\ 3 &amp; 4 \\ \end&#123;vmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><div>$$  \begin{pmatrix} 1 & 2 \\ 3 & 4 \\ \end{pmatrix}   \begin{bmatrix} 1 & 2 \\ 3 & 4 \\ \end{bmatrix}   \begin{vmatrix} 1 & 2 \\ 3 & 4 \\ \end{vmatrix}$$</div><h3 id="Markdown-与-MathJax-语法冲突"><a href="#Markdown-与-MathJax-语法冲突" class="headerlink" title="Markdown 与 MathJax 语法冲突"></a>Markdown 与 MathJax 语法冲突</h3><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>MathJax 语法中的换行应该是 <code>\\</code>，然而由于第一个 <code>\</code> 会被 markdown 解析成转义符，也就相当于只剩下了一个 <code>\</code>，所以有时会使用 <code>\\\</code>，三个反斜线来表示换行。</p><h4 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h4><p><code>_</code> 是 MathJax 语法中的下标连接符，但是在 markdown 语法中，两个 <code>_</code> 中间的文字会被解析成斜体，需要使用 <code>\</code> 进行转义，留下 <code>_</code> 给 MathJax。也就是说，在公式中有时需要使用<code>_</code> 的地方改用 <code>\_</code>。</p><h3 id="通用解决方案"><a href="#通用解决方案" class="headerlink" title="通用解决方案"></a>通用解决方案</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>上文已述，使用转义字符，不提倡</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>手动escape，添加到博文之中，或者修改 js 渲染脚本：</p><figure class="highlight js"><figcaption><span>/nodes_modules/marked/lib/marked.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()# +\-.!_&gt;])/,</span></span><br><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([`*&#123;&#125;\[\]()# +\-.!_&gt;])/</span>,</span><br><span class="line"><span class="comment">//去掉\\转义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br><span class="line"><span class="comment">//去掉_的斜体含义</span></span><br></pre></td></tr></table></figure><p>这种方式可能造成其它的字符会冲突，暂时将就着用，以后随时修改。</p><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>还有一种方法是用 <code>{% raw %}$ 公式 ${% endraw %}</code> 这种形式，即使用 <code>{% raw %}$` 和 `${% endraw %}</code> 把行内代码包起来，不让 markdown 渲染器对公式内部进行渲染。（这里为了打出来这两个标签而不让标签生效，我多打了一遍，让外层的标签起作用，这样就只显示内层标签了）</p><p>这种方法比前两种要好。</p><h4 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h4><p>发现了一个 <a href="https://marketplace.visualstudio.com/items?itemName=goessner.mdmath" target="_blank" rel="noopener">Markdown+Math</a> 插件，可以在 VSCode 里面直接预览 markdown 中的 Latex 公式，不过这个插件还有一些小限制（比如行内公式的 <code>$</code> 与公式之间不能有空格）。</p><p>使用这个插件的话，必须使用纯粹的 Latex 语法，不能用 <code> {% raw %} {% endraw %}</code> 这种多余的符号（这当然更好，博文更纯粹），当然也就要求我们需要对 Hexo 中的 MathJax 渲染问题重新进行配置。</p><p>简单粗暴一步到位的方法 —— 更换渲染器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在主题_config.yml 中配置</span></span><br><span class="line">mathjax: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要先卸载已有的渲染器</span></span><br><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载已经不再维护的 hexo-math 插件</span></span><br><span class="line">npm uninstall hexo-math --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先安装好 pandoc，然后执行如下命令</span></span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><h4 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h4><p>公式显示错乱的本质在于：Latex公式在被mathjax处理之前，被markdown多余处理了一遍。所以我们可以想办法让latex公式绕过markdown的处理。由于大多数markdown渲染器都支持html标签，以此来补足markdown排版短板，我们可以在公式外用一对<code>&lt;div&gt;&lt;/div&gt;</code>包裹起来，以达到这个效果。此外还可以使用<code>&lt;p&gt;&lt;/p&gt;</code>，但是不能使用<code>&lt;span&gt;&lt;/span&gt;</code>。另外需要注意的是，代码块标签前后要加空行。</p><p>行内公式怎么处理？和文字一起，整行包起来就可以了。</p><p>当然，这个方案还有一点小问题，那就是行内公式坐在行还有其他markdown格式符存在的时候怎么办。我的建议是把公式部分拆一行没有格式的出来。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://www.zybuluo.com/knight/note/96093" target="_blank" rel="noopener">MathJax使用LaTeX语法编写数学公式教程 - 作业部落</a></p></li><li><p><a href="http://www.yangzhiping.com/tech/pandoc.html" target="_blank" rel="noopener">Markdown写作进阶：Pandoc入门浅谈 - 阳志平的网志</a></p></li><li><p><a href="http://blog.junyu.io/posts/0013-qa-posts-about-science.html" target="_blank" rel="noopener">Q&amp;A：科学写作中的基本工具和用法 | 浚宇的博客</a></p></li><li><p><a href="http://blog.junyu.io/posts/0011-hexo-math-plugin-test-report.html" target="_blank" rel="noopener">Hexo实现Math公式撰写的实验报告 | 浚宇的博客</a></p></li></ul><h2 id="友善度"><a href="#友善度" class="headerlink" title="友善度"></a>友善度</h2><p>用到再随时补充。</p><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;之前写 &lt;a href=&quot;/2017/10/17/华为面试记（三）&quot;&gt;华为面试记（三）&lt;/a&gt; 的时候，用到了矩阵和数列，因此需要在博客中插
      
    
    </summary>
    
      <category term="实用工具" scheme="http://blogless.github.io/categories/tools/"/>
    
    
      <category term="博客" scheme="http://blogless.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Markdown" scheme="http://blogless.github.io/tags/Markdown/"/>
    
      <category term="MathJax" scheme="http://blogless.github.io/tags/MathJax/"/>
    
  </entry>
  
  <entry>
    <title>华为面试记（三）</title>
    <link href="http://blogless.github.io/2017/10/17/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://blogless.github.io/2017/10/17/华为面试记（三）/</id>
    <published>2017-10-17T05:54:55.000Z</published>
    <updated>2019-09-06T01:30:04.915Z</updated>
    
    <content type="html"><![CDATA[<p align="right"><font size="5" face="黑体"> —— 斐波那契数列 </font></p><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>技术面的面试官让我手写了一个斐波那契数列。在跟面试官确认之后我用迭代的方法写了这道题。<br>（我明明记得斐波那契数列有一个通项公式的，还跟面试官问了一下这种解法，面试官竟然一脸懵逼，是考察点不是这个还是怎么的……</p><p>我跟面试官征求了一下利用数组缓存数据的优化方案，面试官根本不在乎这一点优化 2333</p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>题目描述：</p><div>$$F(n)=    \begin{cases}    1 & \text{n = 1} \\    1 & \text{n = 2} \\    F(n-1)+F(n-2) & \text{n>2}    \end{cases}$$</div><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p>毫无技术含量的递归解法，虽然时空效率不高，但足够简单粗暴，可以用来启发思路。</p><p>面试官曾经说过，<strong>递归转迭代是必备基本技能</strong>。</p><p>直接上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：这里还能优化，详见 <a href="/2017/10/25/奇技淫巧之尾递归/">奇技淫巧之尾递归</a></p></blockquote><h3 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h3><p>显然，递归解法里面存在着大量不必要的重复计算，这里给出迭代解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> ans;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = a + b;</span><br><span class="line">            b = a;</span><br><span class="line">            a = ans;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法时间复杂度O(n)，空间复杂度O(1)。</p><h3 id="矩阵解法"><a href="#矩阵解法" class="headerlink" title="矩阵解法"></a>矩阵解法</h3><p>首先给出公式：</p><div>$$ \begin{bmatrix} f(n) & f(n-1) \\ f(n-1) & f(n-2) \end{bmatrix}= {\begin{bmatrix} 0 & 1 \\ 1 & 1 \end{bmatrix}} ^ {n-1} $$</div><p>证明方法很简单，数学归纳即可。</p><p>至于这种想法怎么来的，方程组不都喜欢用矩阵解嘛  ╮(╯_╰)╭</p><p>直接上程序，没什么可说的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义2×2矩阵；</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix2by2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> m00, m01;</span><br><span class="line">    <span class="keyword">long</span> m10, m11;</span><br><span class="line"></span><br><span class="line">    Matrix2by2(<span class="keyword">long</span> m_00 = <span class="number">1</span>, <span class="keyword">long</span> m_01 = <span class="number">0</span>, <span class="keyword">long</span> m_10 = <span class="number">1</span>, <span class="keyword">long</span> m_11 = <span class="number">0</span>)</span><br><span class="line">        : m00(m_00), m01(m_01), m10(m_10), m11(m_11)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix2by2(<span class="keyword">const</span> Matrix2by2 &amp;mx)</span><br><span class="line">        : m00(mx.m00), m01(mx.m01), m10(mx.m10), m11(mx.m11)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Matrix2by2 <span class="title">matrixMultiply</span><span class="params">(<span class="keyword">const</span> Matrix2by2 &amp;matrix)</span></span>;</span><br><span class="line">    <span class="function">Matrix2by2 <span class="title">matrixPower</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义2×2矩阵的乘法运算</span></span><br><span class="line">Matrix2by2 Matrix2by2::matrixMultiply(<span class="keyword">const</span> Matrix2by2 &amp;matrix)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Matrix2by2 <span class="title">product</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    product.m00 = <span class="keyword">this</span>-&gt;m00 * matrix.m00 + <span class="keyword">this</span>-&gt;m01 * matrix.m10;</span><br><span class="line">    product.m01 = <span class="keyword">this</span>-&gt;m00 * matrix.m01 + <span class="keyword">this</span>-&gt;m01 * matrix.m11;</span><br><span class="line">    product.m10 = <span class="keyword">this</span>-&gt;m10 * matrix.m00 + <span class="keyword">this</span>-&gt;m11 * matrix.m10;</span><br><span class="line">    product.m11 = <span class="keyword">this</span>-&gt;m10 * matrix.m01 + <span class="keyword">this</span>-&gt;m11 * matrix.m11;</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义2×2矩阵的幂运算</span></span><br><span class="line">Matrix2by2 Matrix2by2::matrixPower(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Matrix2by2 <span class="title">matrix</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// I</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        matrix = Matrix2by2(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        matrix = <span class="keyword">this</span>-&gt;matrixPower(n / <span class="number">2</span>);</span><br><span class="line">        matrix = matrix.matrixMultiply(matrix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        matrix = <span class="keyword">this</span>-&gt;matrixPower((n - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        matrix = matrix.matrixMultiply(matrix);</span><br><span class="line">        matrix = matrix.matrixMultiply(Matrix2by2(*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算Fibnacci的第n项</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Matrix2by2 <span class="title">matrix</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    Matrix2by2 fibMatrix = matrix.matrixPower(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> fibMatrix.m00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h3><p>首先给出通项公式：</p><div>$$a_n = \frac{1}{\sqrt{5}} [ (\frac{1+\sqrt{5}}{2}) ^ n - (\frac{1-\sqrt{5}}{2}) ^ n ]$$<div><p>下面给出证明。</p><p>这里用到了高中学过的数列的知识：</p><p>由　$a_{n+2}=a_{n+1}+a_{n}$　可得：</p><p>$a_{n+2} - \frac{1-\sqrt{5}}{2}a_{n+1} = \frac{1+\sqrt{5}}{2} ( a_{n+1} - \frac{1-\sqrt{5}}{2}a_{n} )$  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （１）</p><p>$a_{n+2} - \frac{1+\sqrt{5}}{2}a_{n+1} = \frac{1-\sqrt{5}}{2} ( a_{n+1} - \frac{1+\sqrt{5}}{2}a_{n} )$  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （２）</p><p>由（１）（２）得：</p><p>$a_{n+2} - \frac{1-\sqrt{5}}{2}a_{n+1} = (\frac{1+\sqrt{5}}{2})^n * A$  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （３）</p><p>$a_{n+2} - \frac{1+\sqrt{5}}{2}a_{n+1} = (\frac{1-\sqrt{5}}{2})^n * B$  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （４）</p><p>其中 Ａ、Ｂ 为待定常数，由 $a_1$、$a_2$ 确定</p><p>由（３）（４）得：</p><div>$$ a_{n+2} = (\frac{1-\sqrt{5}}{2})^n * C + (\frac{1+\sqrt{5}}{2})^n * D $$</div><p>其中 C、D 为待定常数，由 $a_1$、$a_2$ 确定</p><p>解得：</p><div>$$ a_n = \frac{1}{\sqrt{5}} [ (\frac{1+\sqrt{5}}{2}) ^ n - (\frac{1-\sqrt{5}}{2}) ^ n ] ,  n > 2 $$</div><p>验证一下，$a_1$、$a_2$ 也符合通项公式。</p><p>当然，利用前面的矩阵也可以推算出数列的通项公式。</p><p>不过通项公式很麻烦的一点是，你怎么在程序里面把 $\sqrt{5}$ 不损失精度地进行计算，因为通项公式虽然包含 $\sqrt{5}$ 但是最终值是一个确定无疑的整数。我觉得这需要一个专业的数学库来计算。</p><p>更多解法可以参考知乎里面的讨论。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="http://www.cnblogs.com/python27/archive/2011/11/25/2261980.html" target="_blank" rel="noopener">【算法02】3种方法求解斐波那契数列- python27 - 博客园</a></p></li><li><p><a href="https://www.zhihu.com/question/25217301" target="_blank" rel="noopener">斐波那契数列通项公式是怎样推导出来的？ -知乎</a></p></li></ul><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p align=&quot;right&quot;&gt;&lt;font size=&quot;5&quot; face=&quot;黑体&quot;&gt; —— 斐波那契数列 &lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;技术面的
      
    
    </summary>
    
    
      <category term="C/C++" scheme="http://blogless.github.io/tags/C-C/"/>
    
      <category term="面试" scheme="http://blogless.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>华为面试记（二）</title>
    <link href="http://blogless.github.io/2017/10/17/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://blogless.github.io/2017/10/17/华为面试记（二）/</id>
    <published>2017-10-17T00:53:57.000Z</published>
    <updated>2019-09-06T01:17:58.783Z</updated>
    
    <content type="html"><![CDATA[<p align="right"><font size="5" face="黑体"> —— 虚函数与成员函数 </font></p><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>华为技术面的面试官问了我一个问题，“C++里面多态是怎么实现的？”</p><p>我当时只答出来说是函数重载，面试官显然对这个答案并不满意，提示我说 “虚函数表”，emmmm ……</p><p>刚好我在论坛里面也看到了这么一道题，那就在这里整理一下，也算纪念一下昨天下午的面试吧。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这两段代码的执行结果是什么，为什么？</p><figure class="highlight c++"><figcaption><span>代码一</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funa</span><span class="params">()</span></span>&#123; <span class="built_in">printf</span>(<span class="string">"hello\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="literal">NULL</span>;</span><br><span class="line">    a-&gt;funa();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>代码二</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">funa</span><span class="params">()</span></span>&#123; <span class="built_in">printf</span>(<span class="string">"hello\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="literal">NULL</span>;</span><br><span class="line">    a-&gt;funa();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（据说这是腾讯的面试题）</p><p>我们看一下，这两段代码的区别是什么呢？只有一点，那就是funa是虚函数还是普通成员函数。问题的另一个关键之处是什么呢，是调用者都是NULL！把握了这两点，基本上答案就呼之欲出了。（所以说大厂校招都是考基础的！</p><h3 id="虚函数的调用"><a href="#虚函数的调用" class="headerlink" title="虚函数的调用"></a>虚函数的调用</h3><p>在上面的例子中，我们对 A 取一下 sizeof 就会发现，代码二中的 sizeof(A) 是 1，而代码一中的 sizeof(A) 是 8（x64环境下）。<br>    <em>ps：可以想想为什么代码二中的 sizeof(A) 是 1 而不是 0</em></p><p>sizeof 访问的是数据段，A 没有任何成员变量，那么这个 8 字节的空间开销是哪里来的呢？就是虚函数表！vptr占用8个字节，指向虚函数表的位置（如图1所示）。没有虚函数的类自然就省去了这部分开jpg销。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="华为面试记（二）_图一.png" alt="华为面试记（二）_图一.png" title>                </div>                <div class="image-caption">华为面试记（二）_图一.png</div>            </figure><p>虚函数在内存空间也是只有一份的，但是在继承过程中，没有被重写（override）的虚函数会共享父类的虚函数，也就是<strong>节约了一份函数开销</strong>（如图二所示）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="华为面试记（二）_图二.png" alt="华为面试记（二）_图二.png" title>                </div>                <div class="image-caption">华为面试记（二）_图二.png</div>            </figure><p>多继承呢？多个虚函数表呗。</p><p>纯虚函数呢？与虚函数的区别仅仅是虚函数没有函数体，而 vtbl 仍然是存在的（参考Java中的接口（Interface）这一概念）。</p><h3 id="普通成员函数、静态成员函数"><a href="#普通成员函数、静态成员函数" class="headerlink" title="普通成员函数、静态成员函数"></a>普通成员函数、静态成员函数</h3><p>类的普通成员函数、静态成员函数是不占用类内存的(<strong>所有的函数都是放在代码段的</strong>，不管是全局函数还是成员函数)。</p><p>普通成员函数的实现和普通的全局函数一样，只不过比全局函数多传入了一个参数，也就是这个对象的指针（有没有想到python里面那个self？？）。实际上，编译器在实现的时候就是这么做的，A::fun(int,int) 会被编译成 fun_A*_int_int()，知道了这个，函数重载很多特性就都很容易理解了。</p><p>静态成员函数不属于某个对象，比普通的成员函数少了一个 this 指针，因而不能访问非静态成员但可以不生成对象来使用（毕竟都编译成普通全局函数了）。</p><h3 id="回到题目中"><a href="#回到题目中" class="headerlink" title="回到题目中"></a>回到题目中</h3><p>现在题目清楚了：NULL 对象能不能访问虚函数？能不能访问普通成员函数？</p><p>因为普通成员函数的调用者在编译期就确定了，在没有访问成员变量的情况下，NULL 对象也可以编译运行（和普通的全局函数没有区别）。但是如果改造一下就不能了：</p><figure class="highlight c++"><figcaption><span>代码二</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">funa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="literal">NULL</span>;</span><br><span class="line">    a-&gt;funa();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，NULL 对象访问成员变量会出错。</p><p>而虚函数的调用者需要在运行期动态绑定，NULL 对象并不能找到虚函数表，自然无法正常运行。</p><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>以下两段代码输出一样吗？为什么？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"hello\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"world\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *b = <span class="keyword">new</span> B;</span><br><span class="line">    b-&gt;fun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"hello\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"world\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *b = <span class="keyword">new</span> B;</span><br><span class="line">    b-&gt;fun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="http://www.cnblogs.com/Ripper-Y/archive/2012/05/15/2501930.html" target="_blank" rel="noopener">C++虚函数与虚函数表 - Hakunamatata- - 博客园</a></p></li><li><p><a href="http://blog.csdn.net/lihao21/article/details/50688337" target="_blank" rel="noopener">C++虚函数表剖析 - Leo的博客 - CSDN博客</a></p></li><li><p><a href="http://www.cnblogs.com/hushpa/p/5707475.html" target="_blank" rel="noopener">C++虚函数表分析 - Jim’sBlog - 博客园</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p align=&quot;right&quot;&gt;&lt;font size=&quot;5&quot; face=&quot;黑体&quot;&gt; —— 虚函数与成员函数 &lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;华为
      
    
    </summary>
    
    
      <category term="C/C++" scheme="http://blogless.github.io/tags/C-C/"/>
    
      <category term="面试" scheme="http://blogless.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>华为面试记（一）</title>
    <link href="http://blogless.github.io/2017/10/17/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://blogless.github.io/2017/10/17/华为面试记（一）/</id>
    <published>2017-10-17T00:30:13.000Z</published>
    <updated>2019-08-25T03:09:15.708Z</updated>
    
    <content type="html"><![CDATA[<p>毫无准备，兵荒马乱地就上了战场，第一战就是华为，还真是莫大的勇气。</p><p>网申之后三天收到在线测评通知，次日收到面试通知，次周一下午，面试。</p><p>技术面的面试官是非常和蔼的一个人，耐心看了我那苍白的简历，并试图从中挖掘出任何有价值的项目经历。</p><p>是的，<strong>项目经历，项目经历，项目经历！</strong>重要的事情说三遍。</p><p>在耐心听完我的介绍之后，开始问我一些计算机基础知识。</p><p>为什么是计算机基础知识？因为这是校招，对于本科生来讲，只有基础知识是最合适的考察标准，专业技能都是要在进公司之后培训的，越是大厂越是如此。当然，如果是社会招聘的话，对不起，面试官只想知道你现在能干什么活儿。所以说，校招进一个靠谱的公司很重要，无论你是想一直在一家干下去还是有中途跳槽的心理准备！</p><p>专业面大概进行了一个小时，一路被面试官按在地上打。之后出来等了一个半小时（？！！）才又叫到我去综合面，这次只持续了三四十分钟的样子。</p><p>说起来综合面真是无所不问，看似闲聊，但总会随时抓住你的漏洞打断你进行追问。尴尬，老底被扒得精光……</p><p>有趣的是，综合面的面试官告诉我说他们的网络是 64k 的网络，通网络不久，数据库什么的也只有少数部门用，23333，也不知是真是假。</p><p>不过总算是完事了，既没有想象的那么恐怖（主要是面试官态度都挺好），也没有很容易（这个主要是自己太水）。总之，两周之后见结果吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;毫无准备，兵荒马乱地就上了战场，第一战就是华为，还真是莫大的勇气。&lt;/p&gt;
&lt;p&gt;网申之后三天收到在线测评通知，次日收到面试通知，次周一下午，面试。&lt;/p&gt;
&lt;p&gt;技术面的面试官是非常和蔼的一个人，耐心看了我那苍白的简历，并试图从中挖掘出任何有价值的项目经历。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="C/C++" scheme="http://blogless.github.io/tags/C-C/"/>
    
      <category term="面试" scheme="http://blogless.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一行脚本搭建局域网服务器</title>
    <link href="http://blogless.github.io/2017/10/06/%E4%B8%80%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%90%AD%E5%BB%BA%E5%B1%80%E5%9F%9F%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://blogless.github.io/2017/10/06/一行脚本搭建局域网服务器/</id>
    <published>2017-10-06T01:32:22.000Z</published>
    <updated>2019-08-25T03:09:15.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><blockquote><p>在电脑上安装的 QQ、微信，一个很重要的功能就是文件传输。当我们需要在电脑和手机之间传输文件的时候，用这种即时通讯工具来传输的做法可谓是深入人心。但是，QQ、微信传输文件也有一些局限性，比如”文件过大无法传输“、”上传下载速度太慢“这些（差点忘了，还可以通过邮件附件传送文件，这种也有大小限制）。对于文件过大，很多人的第一反应是换用百度网盘，先上传云盘然后发送云盘链接，那么很快他们就会遇到第二个问题了（笑）。百度网盘现在是限速的，尽管总有很多奇技淫巧可以绕过这个限制，但是对于伸手党（此处无贬义）来讲，还是太麻烦了。这里，我们借助 Python 提供的工具，来打破文件传输困局。</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先需要说明的是，我们这里搭建的是 <strong>局域网http服务器</strong>，只能用于同一局域网内部的文件传输。也就是说，你的电脑和手机要连入同一个路由器。有人组建路由器网络的话，能不能用？我不知道，我相信会组建路由器网络的人自己就能弄明白这个问题的（试了一下，好像不能）。</p><p>Windows 用户需要两步：安装 python 和 打开服务器。<br>Linux 用户和 macOS 用户请直接进入第二步。</p><h3 id="安装-python"><a href="#安装-python" class="headerlink" title="安装 python"></a>安装 python</h3><p>点击进入<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">官网</a>，选择下载 python 2.x 或者 python 3.x 的版本都可以，我在下文分别对其做了说明。下载完成后，一路下一步完成安装。哦，对，还得记下来你的安装路径，然后添加到环境变量里才行（摔！</p><p>Linux 和 macOS 是自带 python 2.x 运行环境的，如果你是开发人员的话，你可能还装有 python 3.x 版本。</p><h3 id="一行命令开启服务器"><a href="#一行命令开启服务器" class="headerlink" title="一行命令开启服务器"></a>一行命令开启服务器</h3><p>（终于进入正题了）<br>进入需要分享的文件所在目录，然后</p><ul><li>Windows 用户：右键打开 cmd / Powershell / git bash，（随便挑一个，有哪个用哪个）</li><li>Linux / macOS 用户：右键打开 terminal</li></ul><p>输入 Python 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python2 的用法：</span></span><br><span class="line">$ python -m SimpleHTTPServer &lt;port&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 的用法：</span></span><br><span class="line">$ python3 -m http.server &lt;port&gt;</span><br></pre></td></tr></table></figure><p>其中 port 可以不用填写，默认是 8000。</p><p>在本机访问 <a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a> ， 会列出该目录下的所有文件；</p><p>查看 “服务器”(当前电脑) 在局域网的 ip 地址：</p><ul><li>Windows 命令是 ipconfig</li><li>Linux 命令是 ifconfig</li></ul><p>从所给地址中找到当前无线网地址，假设是 192.168.1.3 ，</p><p>在“客户端”（手机浏览器）输入 <code>http://ip:port</code> （比如 192.168.1.3:8000）即可访问“服务器”目录下的文件；</p><p>注意，如果目录下有 index.html 文件的话，则显示的不是文件列表而是 index.html 的内容。</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>当然，传输文件的方法太多了，不一定要用这种。其他的一些，比如有的邮箱会有【文件中转站】【网络硬盘】这些附加功能，可以用来传输文件；微软有个 OneDrive 也可以存文件；通过 手机安装 ES文件管理器，或者 AirDroid 这些软件，也都可以传输文件。</p><p>那么，这种搭建局域网服务器的优势是什么呢？</p><ul><li>没有账户登录的操作，</li><li>省去了上传这一步，</li><li>不用安装任何软件（骗人，明明需要安装python</li></ul><p>当然，这种方案也有劣势：</p><ul><li>很多人根本不会操作命令行，</li><li>不知道环境变量是什么东西，</li><li>没有遇到问题随手搜索的习惯。</li></ul><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>Windows 小白用户看看热闹就好。</p><h2 id="干货"><a href="#干货" class="headerlink" title="干货"></a>干货</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python2 的用法：</span></span><br><span class="line">$ python -m SimpleHTTPServer &lt;port&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># python3 的用法：</span></span><br><span class="line">$ python3 -m http.server &lt;port&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Windows 命令查看局域网地址</span></span><br><span class="line">$ ipconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux 命令查看局域网地址</span></span><br><span class="line">$ ifconfig</span><br></pre></td></tr></table></figure><h2 id="友善度"><a href="#友善度" class="headerlink" title="友善度"></a>友善度</h2><p>不管你能不能用，反正我是能用的（deepin 15.4.1 + Win7）</p><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在电脑上安装的 QQ、微信，一个很重要的功能就是文件传输。当我们需要在电脑和手机之间传输文件的时候，用这种即时通讯
      
    
    </summary>
    
      <category term="实用工具" scheme="http://blogless.github.io/categories/tools/"/>
    
    
      <category term="Python" scheme="http://blogless.github.io/tags/Python/"/>
    
      <category term="服务器" scheme="http://blogless.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Mysql常用操作</title>
    <link href="http://blogless.github.io/2017/10/05/Mysql%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://blogless.github.io/2017/10/05/Mysql常用操作/</id>
    <published>2017-10-05T09:41:37.000Z</published>
    <updated>2019-09-05T11:44:35.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><blockquote><p>上一篇写 C API 操作 Mysql 的时候，本来打算简单陈列一下常用 Mysql 命令，结果发现篇幅太长，于是摘出来单独写了这篇 Mysql 常用操作总结。</p></blockquote><h2 id="干货"><a href="#干货" class="headerlink" title="干货"></a>干货</h2><p>这里只简单陈列一下 <strong>个人在私人数据库上</strong> 的常用操作：</p><p><em>说明一下，下面用&lt;&gt;包括起来的内容是操作时需要替换的部分，但是在含有sql脚本的语句中被替换成了【】</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登入/登出</span></span><br><span class="line">mysql -u &lt;用户名&gt; -p <span class="comment"># 登录 mysql，自己一个人用的话用户名 root 就行，下一行需要输入密码</span></span><br><span class="line">quit    <span class="comment"># 退出 mysq</span></span><br><span class="line"><span class="built_in">exit</span>    <span class="comment"># 退出 mysq</span></span><br><span class="line">^C      <span class="comment"># 退出 mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统信息</span></span><br><span class="line">select user();      <span class="comment"># 查看当前用户</span></span><br><span class="line">select version();   <span class="comment"># 查看当前数据库版本</span></span><br><span class="line">show variables like <span class="string">'collation_%'</span>;  <span class="comment"># 查看当前使用的字符集</span></span><br><span class="line">show character <span class="built_in">set</span>;                 <span class="comment"># 查看可以支持的字符集</span></span><br><span class="line">alter database &lt;表名称&gt; character <span class="built_in">set</span> utf-8;   <span class="comment"># 修改数据库的字符集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库操作</span></span><br><span class="line">create database &lt;新数据库名称&gt;;   <span class="comment"># 创建数据库</span></span><br><span class="line">show databases;     <span class="comment"># 显示所有数据库</span></span><br><span class="line">use &lt;数据库名称&gt;；    <span class="comment"># 进入数据库</span></span><br><span class="line">drop &lt;数据库名称&gt;；   <span class="comment"># 删除数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表操作</span></span><br><span class="line">create table &lt;新表名称&gt;(    </span><br><span class="line">    &lt;字段1&gt;&lt;数据类型1&gt;,</span><br><span class="line">    &lt;字段2&gt;&lt;数据类型2&gt;,</span><br><span class="line">    ...</span><br><span class="line">    );              <span class="comment"># 创建表</span></span><br><span class="line">show tables;        <span class="comment"># 显示所有表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表内操作</span></span><br><span class="line">descbile &lt;表名称&gt;;   <span class="comment"># 显示表的数据结构</span></span><br><span class="line">select * from &lt;表名称&gt;;   <span class="comment"># 显示表内容</span></span><br><span class="line">insert into &lt;表名称&gt; </span><br><span class="line">    [(&lt;字段1&gt;，&lt;字段2&gt;,&lt;字段3&gt;)] </span><br><span class="line">    values (&lt;值1&gt;，&lt;值2&gt;，&lt;值3&gt;);    <span class="comment"># 向表内添加数据</span></span><br><span class="line">update &lt;表名称&gt; </span><br><span class="line">    <span class="built_in">set</span> &lt;字段1&gt; = &lt;新值1&gt;，&lt;字段2&gt; = &lt;新值2&gt;</span><br><span class="line">    <span class="built_in">where</span> &lt;字段x&gt; = &lt;新值x&gt;;        <span class="comment"># 更新表中字段</span></span><br><span class="line">delete from &lt;表名称&gt; </span><br><span class="line">    <span class="built_in">where</span> &lt;条件筛选&gt;;               <span class="comment"># 删除指定记录</span></span><br><span class="line">delete from &lt;表名称&gt;；              <span class="comment"># 删除整个表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表结构的修改</span></span><br><span class="line">alter table &lt;旧表名&gt; rename to &lt;新表名&gt;;  <span class="comment"># 修改表名</span></span><br><span class="line">alter table &lt;表名称&gt; add primary key(&lt;字段名称&gt;);   <span class="comment"># 把某个字段设置为主键</span></span><br><span class="line">alter table &lt;表名称&gt; drop primary key(&lt;字段名称&gt;);  <span class="comment"># 把某个字段删除主键定义</span></span><br><span class="line">alter table &lt;表名称&gt; add &lt;字段名称&gt; &lt;数据类型&gt;;    <span class="comment"># 增加字段并规定数据类型</span></span><br><span class="line">alter table &lt;表名称&gt; drop &lt;字段名称&gt;;             <span class="comment"># 删除字段</span></span><br><span class="line">alter table &lt;表名称&gt; modify &lt;字段名称&gt; &lt;数据类型&gt; [not null];     <span class="comment"># 修改字段属性</span></span><br><span class="line">alter table &lt;表名称&gt; change &lt;旧字段名称&gt; &lt;新字段名称&gt; &lt;数据类型&gt;;   <span class="comment"># 修改字段名</span></span><br><span class="line"></span><br><span class="line">create table &lt;旧表名称&gt; like &lt;旧表名称&gt;;        <span class="comment"># 用旧表的架构建立一个新的空表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># I/O 操作</span></span><br><span class="line">mysql &lt; a.sql           <span class="comment"># 对当前数据库执行外部脚本</span></span><br><span class="line">mysql 【表名称】 &lt; a.sql  <span class="comment"># 对指定数据库执行外部脚本</span></span><br><span class="line"></span><br><span class="line">load data <span class="built_in">local</span> infile <span class="string">"&lt;文件名&gt;"</span> into &lt;表名称&gt;;      <span class="comment"># 数据传入</span></span><br></pre></td></tr></table></figure><p>注意，大部分 mysql 操作命令都是以“;”（或者“\g”）结尾的，这一点与 C 语言是一致的；少部分不能加”;“，比如执行外部脚本和备份数据库这种。</p><h2 id="友善度"><a href="#友善度" class="headerlink" title="友善度"></a>友善度</h2><p>博主水平有限，记录的内容难免有所疏漏和不足，欢迎评论补充 ～</p><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;上一篇写 C API 操作 Mysql 的时候，本来打算简单陈列一下常用 Mysql 命令，结果发现篇幅太长，于是
      
    
    </summary>
    
      <category term="数据库" scheme="http://blogless.github.io/categories/sql/"/>
    
    
      <category term="Mysql" scheme="http://blogless.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>C++ 操作 Mysql</title>
    <link href="http://blogless.github.io/2017/10/05/C-%E6%93%8D%E4%BD%9C-Mysql/"/>
    <id>http://blogless.github.io/2017/10/05/C-操作-Mysql/</id>
    <published>2017-10-05T08:24:07.000Z</published>
    <updated>2019-08-25T03:09:15.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><blockquote><p>写 C++ 的时候，突然想到，以前都是在用 php 操作 Mysql，那用 C/C++ 操作 Mysql 是怎样的一种体验呢？（笑<br>当然，php 操作 Mysql 是最舒服的，可是我就是想用 C 来操作试试。实际上，C API 才是最不可或缺的 API，其他的 API 可能很多都是 C API 的包装。</p></blockquote><p>那就开始吧！</p><p>我是在 deepin 15.4.1 上完成的操作，其他 Linux 环境请自行摸索。</p><h2 id="安装-Mysql"><a href="#安装-Mysql" class="headerlink" title="安装 Mysql"></a>安装 Mysql</h2><p>必备组件的包括：</p><ul><li>mysql-client，用来连接 mysql 数据库并发起操作请求</li><li>mysql-server，响应 Mysql 操作请求并返回结果</li><li>mysql-devel，库和包含文件，我们需要的头文件和动态连接库就在这里面；在 debian 系，它的名字叫 libmysqld-dev（好像 Redhat 系的 -devel 在 Ubuntu 系都叫 -dev）。</li></ul><p>安装好上面3个包，我们就可以开心地使用 Mysql 数据库了。</p><h2 id="建立所需数据库"><a href="#建立所需数据库" class="headerlink" title="建立所需数据库"></a>建立所需数据库</h2><p>首先我们尝试建立一个测试用的数据库，<del>这里简单陈列一下常用操作</del>，写完发现太长了，我决定单开一篇整理 Mysql 操作。</p><p>总之，我假设你已经自己建立起了一个数据库 test，里面包括一个表 samples，其数据结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| name    | varchar(40) | NO   |     | NULL    |       |</span><br><span class="line">| country | varchar(40) | NO   |     | NULL    |       |</span><br><span class="line">| number  | int(11)     | NO   |     | NULL    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br></pre></td></tr></table></figure><p>假定你已经在 samples 里面存放了几个数据。我的 samples 所含数据如下：</p><blockquote><p>elect * from samples;</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-----------+---------+--------+</span><br><span class="line">| name      | country | number |</span><br><span class="line">+-----------+---------+--------+</span><br><span class="line">| Beijing   | China   |      1 |</span><br><span class="line">| Shanghai  | China   |      2 |</span><br><span class="line">| Shenzhen  | China   |      3 |</span><br><span class="line">| Guangzhou | China   |      4 |</span><br><span class="line">| Hangzhou  | China   |      5 |</span><br><span class="line">| Nanjing   | China   |      6 |</span><br><span class="line">| Wuhan     | China   |      7 |</span><br><span class="line">| Chongqing | China   |      8 |</span><br><span class="line">+-----------+---------+--------+</span><br></pre></td></tr></table></figure><p>现在，我们已经有了可以用的数据库，接下来就是我们真正需要的用 C 来访问 Mysql 了。</p><h2 id="C-程序编写"><a href="#C-程序编写" class="headerlink" title="C 程序编写"></a>C 程序编写</h2><p>这里直接贴上我的测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"/usr/include/mysql/mysql.h"</span>   <span class="comment">// mysql.h 所在路径</span></span></span><br><span class="line"><span class="comment">// 【编译】时需要加上 -lmysqlclient 选项       // 运行时所需动态库</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> user[] = <span class="string">"root"</span>;         <span class="comment">//username</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> pswd[] = <span class="string">"休想！"</span>; <span class="comment">//password</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> host[] = <span class="string">"localhost"</span>;    <span class="comment">//or"127.0.0.1"</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> database[] = <span class="string">"test"</span>;     <span class="comment">//database</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> port = <span class="number">3306</span>;           <span class="comment">//server port</span></span><br><span class="line"></span><br><span class="line">    MYSQL mysql;</span><br><span class="line">    MYSQL_RES *result = <span class="literal">NULL</span>;</span><br><span class="line">    MYSQL_FIELD *fd;</span><br><span class="line">    MYSQL_ROW sql_row;</span><br><span class="line">    <span class="keyword">char</span> column[<span class="number">32</span>][<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化MYSQL变量</span></span><br><span class="line">    mysql_init(&amp;mysql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接Mysql服务器</span></span><br><span class="line">    <span class="keyword">if</span> (!mysql_real_connect(&amp;mysql, host, user, pswd, database, port, <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"mysql_real_connect failed!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mysql_query(&amp;mysql, "SET NAMES GBK"); //cmd下需设置编码格式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询当前数据库中的samples表</span></span><br><span class="line">    <span class="keyword">if</span> (mysql_query(&amp;mysql, <span class="string">"select * from samples"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"mysql_query failed!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存查询到的数据到result</span></span><br><span class="line">    result = mysql_store_result(&amp;mysql);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"mysql_store_result failed!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num_rows = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)mysql_num_rows(result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"number of result: %d\n"</span>, num_rows);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; fd = mysql_fetch_field(result); i++) <span class="comment">//获取列名</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(column[i], fd-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num_cols = mysql_num_fields(result);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_cols; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%-10s\t"</span>, column[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sql_row = mysql_fetch_row(result)) <span class="comment">//获取具体的数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_cols; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%-10s\t"</span>, sql_row[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mysql_free_result(result); <span class="comment">//释放结果资源</span></span><br><span class="line">    mysql_close(&amp;mysql);       <span class="comment">//断开连接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="干货"><a href="#干货" class="headerlink" title="干货"></a>干货</h2><p>干货？不存在的！只要去查 Mysql 的 C API 就完了。哪里不会 Google 哪里～</p><h2 id="友善度"><a href="#友善度" class="headerlink" title="友善度"></a>友善度</h2><p>博主现在还是学生，根本没有在生产环境下实操过，水平有限，所以记录的内容难免有所疏漏和不足，欢迎评论补充 ～</p><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;写 C++ 的时候，突然想到，以前都是在用 php 操作 Mysql，那用 C/C++ 操作 Mysql 是怎样的
      
    
    </summary>
    
      <category term="数据库" scheme="http://blogless.github.io/categories/sql/"/>
    
    
      <category term="C/C++" scheme="http://blogless.github.io/tags/C-C/"/>
    
      <category term="Mysql" scheme="http://blogless.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>使用 hexo 搭建 github 博客</title>
    <link href="http://blogless.github.io/2017/10/05/setup-blog/"/>
    <id>http://blogless.github.io/2017/10/05/setup-blog/</id>
    <published>2017-10-05T02:01:55.000Z</published>
    <updated>2019-09-06T01:24:51.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><blockquote><p>搭建一个属于自己的博客的想法由来已久，可是直到现在我才动手。这里面的原因当然很多，不过最重要的原因当然还是懒（&gt;.&lt;）。一来自己还没有固定的居所，想要自己本地建站还不稳定；二来嘛，则是平常没什么功夫去写博客，写个文章还要想着美工什么的实在让人心烦。不过现在这些都不是问题了，可以把博客架在云上，也有时间操弄自己的博客了。现在暂时还是先把博客放在 github 上，以后可能考虑会放到 阿里云 上（谁知道什么时候才会动手……）。</p></blockquote><hr><h2 id="建站方案选择"><a href="#建站方案选择" class="headerlink" title="建站方案选择"></a>建站方案选择</h2><p>当然是先要在 <del>全球最大的同性社交网站</del> github 建一个主页了！</p><p><a href="https://pages.github.com/" target="_blank" rel="noopener">github pages</a> 是必须要的，官方给了一个建站方案是 jekyll，当然我也首先试了一下官方方案，不过发现自己并不喜欢这个方案，最重要的原因是 —— 需要多安装一个 Ruby！我对此事是拒绝的，因为我并不想安装一些平常用不到的东西（别误会，我对 Ruby 本身并没有偏见）。</p><p>之后我发现了使用 Node.js 的 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>，这才是我想要的！</p><h2 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h2><p>好吧，这里没什么可写的，写得再多也没有 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo官网</a> 权威、时效性强，需要建站的话，直接参考 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo官网</a> 就好了。</p><p>这里只说几个新手可能遇到的问题，老司机们请抄近道。</p><h3 id="npm-的配置"><a href="#npm-的配置" class="headerlink" title="npm 的配置"></a>npm 的配置</h3><p>虽然有了更为先进的 yarn，我还是固守在 npm 的身边，毕竟用习惯了。这里使用 npm 可能出现的问题是超时。原因嘛，npm 服务器在国外，经常被墙。国内的用户们想要使用 npm 的话，可以选择 <a href="https://npm.taobao.org/mirrors/npm/" target="_blank" rel="noopener">淘宝镜像</a>。当然，它会很热情地推荐你使用 cnpm 来代替 npm，不要理它。<br>关于如何配置淘宝镜像，网上很容易搜到，其实一行命令就好：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置 registry</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://r.cnpmjs.org/</span><br><span class="line"><span class="comment"># 验证配置是否修改成功</span></span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><h3 id="theme-的切换"><a href="#theme-的切换" class="headerlink" title="theme 的切换"></a>theme 的切换</h3><p>安装之后，默认的 landscape 主题我是拒绝的，选择一个能够长时间忍受的主题还是很有必要的。我在 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网</a> 上找到了一个 Material Design 的 indigo 主题。没错，就是你现在看到的这个！<br>安装 indigo 主题，请戳 <a href="https://github.com/yscoder/hexo-theme-indigo/wiki" target="_blank" rel="noopener">作者的github</a>，按照大佬的指导一步步来就行了。</p><h2 id="调教博客"><a href="#调教博客" class="headerlink" title="调教博客"></a>调教博客</h2><h3 id="修改侧边栏为中文"><a href="#修改侧边栏为中文" class="headerlink" title="修改侧边栏为中文"></a>修改侧边栏为中文</h3><p>进入 indigo 的配置文件（_config.yml），仿照【menu-home】，在【menu-archives】等下面几个 menu 的配置里，分别加上 text 属性作为显示的名称：</p><figure class="highlight yml"><figcaption><span>/themes/indigo/_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span></span><br><span class="line"><span class="attr">    text:</span> <span class="string">主页</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  archives:</span></span><br><span class="line"><span class="attr">    text:</span> <span class="string">归档</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">/archives</span></span><br></pre></td></tr></table></figure><p>然后可以修改后面的【tags_title】【archives_title】【categories_title】属性，作为从 menu 进入相应页面后的标题：</p><figure class="highlight yml"><figcaption><span>/themes/indigo/_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 页面标题</span></span><br><span class="line"><span class="attr">tags_title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">archives_title:</span> <span class="string">归档</span></span><br><span class="line"><span class="attr">categories_title:</span> <span class="string">分类</span></span><br></pre></td></tr></table></figure><h3 id="tags-amp-categories"><a href="#tags-amp-categories" class="headerlink" title="tags &amp; categories"></a>tags &amp; categories</h3><p>下面将以 tags 为例进行说明，categories 同理设置即可。</p><p>首先需要开启 hexo 的 tags 功能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>此时会生成一个新的文件 source/tags/index.md，修改其内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2017-10-04 19:50:45</span><br><span class="line">type: "tags"</span><br><span class="line">layout: "tags"</span><br><span class="line">comment: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>修改 scaffolds/draft.md：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">tags: &#123;&#123; tags &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>修改 scaffolds/post.md：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags: &#123;&#123; tags &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>检查 indigo 主题下的 menu-tags 是否打开：</p><figure class="highlight yml"><figcaption><span>/themes/indigo/_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">    tags:</span> <span class="string">/tags</span></span><br></pre></td></tr></table></figure><p>最后是自己的文章里要有相应的 tags 来区分，比如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 使用hexo搭建github博客</span><br><span class="line">date: 2017-10-05 10:01:55</span><br><span class="line">tags: [随笔, 博客]</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>注意冒号之后的空格，以及“,”要用半角不要用全角，否则程序会不认。</p><h3 id="返回顶部"><a href="#返回顶部" class="headerlink" title="返回顶部"></a>返回顶部</h3><p>hexo 竟然没有自带返回顶部的按钮，好奇怪。不过自己做一个也费不了什么功夫。我打算自己做一个，稍后发上来。</p><h3 id="代码自动换行"><a href="#代码自动换行" class="headerlink" title="代码自动换行"></a>代码自动换行</h3><p>有空再做</p><h3 id="插入图片设置"><a href="#插入图片设置" class="headerlink" title="插入图片设置"></a>插入图片设置</h3><p>图片路径有两种，一种是绝对路径，可以将图片单独存放在source/images路径下，通过类似</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](/images/image1.jpg)</span><br></pre></td></tr></table></figure><p>这种方式来插入图片。</p><p>另一种是相对路径，图片可以和博文放在同目录下，这种方法需要调整一下配置文件：</p><figure class="highlight yml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>以后再执行命令$ hexo new <post_name>时，hexo就会在生成文章post_name.md的同时，生成同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了，类似于这种用法：</post_name></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](image1.jpg)</span><br></pre></td></tr></table></figure><h3 id="插入公式支持"><a href="#插入公式支持" class="headerlink" title="插入公式支持"></a>插入公式支持</h3><p>Hexo 博客中插入公式方案，我选的是 <a href="https://www.mathjax.org/" target="_blank" rel="noopener">MathJax</a> ，参见 <a href="/2017/10/18/Hexo博客插入数学公式/">Hexo博客插入数学公式</a></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>踩过的一个坑:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br><span class="line">无法读取远程存储库。</span><br><span class="line"></span><br><span class="line">请确保你有正确的访问权限和存储库的存在。</span><br></pre></td></tr></table></figure><p>出现这种错误，有可能在配置 _config.yml 的时候，deploy 没有写全，或者 repo 的写法不对，参考如下格式：</p><figure class="highlight yml"><figcaption><span>/_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">http://github.com/username/username.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>这里，我们可以把生成、部署的命令，写成一个脚本，这样就不用去刻意记命令了：</p><figure class="highlight bash"><figcaption><span>/upload.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># hexo clean    # 清理</span></span><br><span class="line">hexo generate <span class="comment"># 生成</span></span><br><span class="line">hexo deploy   <span class="comment"># 部署</span></span><br></pre></td></tr></table></figure><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>评论系统；<br>分享功能；<br>目录折叠；<br>代码高亮调整（比如bash）、行号隐藏显示可调；</p><h2 id="干货"><a href="#干货" class="headerlink" title="干货"></a>干货</h2><p>所以这篇博客到底说了什么呢？</p><p>什么也没说，只是把 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo建站方案</a> 和 <a href="https://github.com/yscoder/hexo-theme-indigo/wiki" target="_blank" rel="noopener">indigo主题</a> 两个网址甩给了你，不会就找官方嘛！</p><p>嗯，其实我就是来测试自己搭的博客是不是能用的 O(∩_∩)O</p><h2 id="友善度"><a href="#友善度" class="headerlink" title="友善度"></a>友善度</h2><p>由于这篇博文是在博客搭建得差不多才开始写的，所以记录的内容可能有所疏漏，欢迎评论补充 ～</p><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;搭建一个属于自己的博客的想法由来已久，可是直到现在我才动手。这里面的原因当然很多，不过最重要的原因当然还是懒（&amp;g
      
    
    </summary>
    
      <category term="随笔" scheme="http://blogless.github.io/categories/other/"/>
    
    
      <category term="博客" scheme="http://blogless.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="随笔" scheme="http://blogless.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://blogless.github.io/2017/10/04/hello-world/"/>
    <id>http://blogless.github.io/2017/10/04/hello-world/</id>
    <published>2017-10-04T04:00:00.000Z</published>
    <updated>2019-08-25T03:09:15.676Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
